2020-04-29 11:46:34.601  INFO 21108 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 21108 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 11:46:34.605  INFO 21108 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 11:46:39.111  WARN 21108 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 11:46:39.576  INFO 21108 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 5.346 seconds (JVM running for 9.057)
2020-04-29 11:46:42.782  WARN 21108 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
2020-04-29 11:46:42.828  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:46:42.826开始执行count
2020-04-29 11:46:42.962  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:46:42.962执行完成count
2020-04-29 11:46:42.962  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:46:42.975  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:46:42.975开始执行index
2020-04-29 11:46:43.081  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:46:43.081执行完成index
2020-04-29 11:46:43.081  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:47:33.212  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:47:33.212开始执行count
2020-04-29 11:47:33.249  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:47:33.249执行完成count
2020-04-29 11:47:33.250  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:47:33.254  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:47:33.254开始执行index
2020-04-29 11:47:33.327  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:47:33.327执行完成index
2020-04-29 11:47:33.327  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:48:25.209  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:48:25.209开始执行count
2020-04-29 11:48:25.245  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:48:25.245执行完成count
2020-04-29 11:48:25.245  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:48:25.250  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:48:25.250开始执行index
2020-04-29 11:48:25.322  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:48:25.322执行完成index
2020-04-29 11:48:25.322  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:49:05.467  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:49:05.467开始执行count
2020-04-29 11:49:05.503  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:49:05.503执行完成count
2020-04-29 11:49:05.504  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:49:05.507  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:49:05.507开始执行index
2020-04-29 11:49:05.581  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:49:05.581执行完成index
2020-04-29 11:49:05.581  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:50:22.196  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:50:22.196开始执行count
2020-04-29 11:50:22.281  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:50:22.281执行完成count
2020-04-29 11:50:22.281  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:50:22.285  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:50:22.285开始执行index
2020-04-29 11:50:22.357  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:50:22.357执行完成index
2020-04-29 11:50:22.357  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:50:24.086  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:50:24.086开始执行count
2020-04-29 11:50:24.122  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:50:24.122执行完成count
2020-04-29 11:50:24.123  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:50:24.127  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:50:24.127开始执行index
2020-04-29 11:50:24.198  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:50:24.198执行完成index
2020-04-29 11:50:24.198  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:50:40.105  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:50:40.105开始执行count
2020-04-29 11:50:40.141  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:50:40.141执行完成count
2020-04-29 11:50:40.141  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:50:40.146  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:50:40.146开始执行index
2020-04-29 11:50:40.217  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:50:40.217执行完成index
2020-04-29 11:50:40.217  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:50:41.334  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:50:41.334开始执行count
2020-04-29 11:50:41.370  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:50:41.370执行完成count
2020-04-29 11:50:41.370  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:50:41.374  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:50:41.374开始执行index
2020-04-29 11:50:41.456  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:50:41.456执行完成index
2020-04-29 11:50:41.457  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:51:08.023  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:51:08.023开始执行count
2020-04-29 11:51:08.059  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:51:08.059执行完成count
2020-04-29 11:51:08.060  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:51:08.064  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:51:08.064开始执行index
2020-04-29 11:51:08.134  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:51:08.134执行完成index
2020-04-29 11:51:08.134  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:52:23.058  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.058开始执行count
2020-04-29 11:52:23.130  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.130执行完成count
2020-04-29 11:52:23.130  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:52:23.134  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.134开始执行index
2020-04-29 11:52:23.204  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.204执行完成index
2020-04-29 11:52:23.205  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:52:23.792  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.792开始执行count
2020-04-29 11:52:23.828  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.828执行完成count
2020-04-29 11:52:23.828  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:52:23.833  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.833开始执行index
2020-04-29 11:52:23.903  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:52:23.903执行完成index
2020-04-29 11:52:23.903  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:52:49.456  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.456开始执行count
2020-04-29 11:52:49.493  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.493执行完成count
2020-04-29 11:52:49.493  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:52:49.499  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.499开始执行index
2020-04-29 11:52:49.568  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.568执行完成index
2020-04-29 11:52:49.568  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:52:49.753  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.753开始执行count
2020-04-29 11:52:49.788  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.788执行完成count
2020-04-29 11:52:49.789  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:52:49.792  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.792开始执行index
2020-04-29 11:52:49.862  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:52:49.862执行完成index
2020-04-29 11:52:49.862  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:22.514  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:55:22.514开始执行count
2020-04-29 11:55:22.588  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:55:22.588执行完成count
2020-04-29 11:55:22.588  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:22.602  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:55:22.602开始执行index
2020-04-29 11:55:22.678  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:55:22.678执行完成index
2020-04-29 11:55:22.679  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:23.460  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:23.460开始执行count
2020-04-29 11:55:23.496  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:23.496执行完成count
2020-04-29 11:55:23.496  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:23.500  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:55:23.500开始执行index
2020-04-29 11:55:23.572  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:55:23.572执行完成index
2020-04-29 11:55:23.572  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:24.155  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.155开始执行count
2020-04-29 11:55:24.189  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.189执行完成count
2020-04-29 11:55:24.189  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:24.193  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.193开始执行index
2020-04-29 11:55:24.265  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.265执行完成index
2020-04-29 11:55:24.265  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:24.373  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.373开始执行count
2020-04-29 11:55:24.408  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.408执行完成count
2020-04-29 11:55:24.408  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:24.412  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.412开始执行index
2020-04-29 11:55:24.488  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.488执行完成index
2020-04-29 11:55:24.489  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:24.597  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.597开始执行count
2020-04-29 11:55:24.632  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.632执行完成count
2020-04-29 11:55:24.632  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:24.636  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.636开始执行index
2020-04-29 11:55:24.705  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.705执行完成index
2020-04-29 11:55:24.705  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:24.798  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.798开始执行count
2020-04-29 11:55:24.835  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.835执行完成count
2020-04-29 11:55:24.835  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:24.843  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.843开始执行index
2020-04-29 11:55:24.925  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:24.925执行完成index
2020-04-29 11:55:24.925  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:26.595  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:26.595开始执行count
2020-04-29 11:55:26.629  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:26.629执行完成count
2020-04-29 11:55:26.630  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:26.634  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:26.634开始执行index
2020-04-29 11:55:26.702  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:26.702执行完成index
2020-04-29 11:55:26.702  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:32.247  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:32.247开始执行count
2020-04-29 11:55:32.282  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:32.282执行完成count
2020-04-29 11:55:32.282  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:32.287  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:32.287开始执行index
2020-04-29 11:55:32.356  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:32.356执行完成index
2020-04-29 11:55:32.356  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:33.159  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.159开始执行count
2020-04-29 11:55:33.195  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.194执行完成count
2020-04-29 11:55:33.195  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:33.199  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.198开始执行index
2020-04-29 11:55:33.266  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.266执行完成index
2020-04-29 11:55:33.266  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:33.833  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.833开始执行count
2020-04-29 11:55:33.874  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.874执行完成count
2020-04-29 11:55:33.874  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:33.878  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.878开始执行index
2020-04-29 11:55:33.951  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:33.951执行完成index
2020-04-29 11:55:33.951  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:34.066  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.066开始执行count
2020-04-29 11:55:34.103  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.103执行完成count
2020-04-29 11:55:34.103  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:34.107  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.107开始执行index
2020-04-29 11:55:34.189  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.189执行完成index
2020-04-29 11:55:34.189  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:34.295  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.295开始执行count
2020-04-29 11:55:34.329  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.329执行完成count
2020-04-29 11:55:34.329  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:34.333  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.333开始执行index
2020-04-29 11:55:34.402  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.402执行完成index
2020-04-29 11:55:34.402  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:34.513  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.513开始执行count
2020-04-29 11:55:34.551  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.551执行完成count
2020-04-29 11:55:34.551  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:34.560  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.560开始执行index
2020-04-29 11:55:34.638  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.638执行完成index
2020-04-29 11:55:34.638  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:34.757  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.757开始执行count
2020-04-29 11:55:34.791  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.791执行完成count
2020-04-29 11:55:34.791  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:34.795  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.795开始执行index
2020-04-29 11:55:34.865  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.865执行完成index
2020-04-29 11:55:34.865  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:34.972  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:34.972开始执行count
2020-04-29 11:55:35.006  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.006执行完成count
2020-04-29 11:55:35.006  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:35.013  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.013开始执行index
2020-04-29 11:55:35.084  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.084执行完成index
2020-04-29 11:55:35.084  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:35.139  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.139开始执行count
2020-04-29 11:55:35.174  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.174执行完成count
2020-04-29 11:55:35.174  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:35.178  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.178开始执行index
2020-04-29 11:55:35.255  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.255执行完成index
2020-04-29 11:55:35.256  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:35.370  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.370开始执行count
2020-04-29 11:55:35.405  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.405执行完成count
2020-04-29 11:55:35.406  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:35.412  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.412开始执行index
2020-04-29 11:55:35.482  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.482执行完成index
2020-04-29 11:55:35.482  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:35.541  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.541开始执行count
2020-04-29 11:55:35.576  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.576执行完成count
2020-04-29 11:55:35.576  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:35.580  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.580开始执行index
2020-04-29 11:55:35.648  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:55:35.648执行完成index
2020-04-29 11:55:35.648  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:44.031  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:44.031开始执行count
2020-04-29 11:55:44.067  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:55:44.067执行完成count
2020-04-29 11:55:44.067  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:55:44.070  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:44.070开始执行index
2020-04-29 11:55:44.139  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:55:44.139执行完成index
2020-04-29 11:55:44.139  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:57.668  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:55:57.668开始执行index
2020-04-29 11:55:57.739  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:55:57.739执行完成index
2020-04-29 11:55:57.740  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:55:59.903  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:55:59.903开始执行index
2020-04-29 11:55:59.971  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:55:59.971执行完成index
2020-04-29 11:55:59.971  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:56:06.300  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:56:06.300开始执行getContent
2020-04-29 11:56:06.366  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:56:06.366执行完成getContent
2020-04-29 11:56:06.366  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:57:10.188  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:57:10.188开始执行getContent
2020-04-29 11:57:10.264  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:57:10.264执行完成getContent
2020-04-29 11:57:10.264  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:57:10.772  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:57:10.772开始执行getContent
2020-04-29 11:57:10.810  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:57:10.810执行完成getContent
2020-04-29 11:57:10.811  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:57:10.987  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:57:10.987开始执行getContent
2020-04-29 11:57:11.024  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:57:11.024执行完成getContent
2020-04-29 11:57:11.024  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:57:11.214  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:57:11.214开始执行getContent
2020-04-29 11:57:11.250  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:57:11.250执行完成getContent
2020-04-29 11:57:11.250  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:57:11.424  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:57:11.423开始执行getContent
2020-04-29 11:57:11.461  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:57:11.461执行完成getContent
2020-04-29 11:57:11.461  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:58:47.990  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:58:47.990开始执行count
2020-04-29 11:58:48.063  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:58:48.063执行完成count
2020-04-29 11:58:48.063  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:58:48.068  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:58:48.068开始执行index
2020-04-29 11:58:48.137  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:58:48.137执行完成index
2020-04-29 11:58:48.137  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:58:48.919  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:58:48.919开始执行count
2020-04-29 11:58:48.954  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:58:48.954执行完成count
2020-04-29 11:58:48.954  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:58:48.963  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:58:48.963开始执行index
2020-04-29 11:58:49.032  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:58:49.032执行完成index
2020-04-29 11:58:49.032  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:58:49.693  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:58:49.693开始执行count
2020-04-29 11:58:49.731  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:58:49.731执行完成count
2020-04-29 11:58:49.731  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 11:58:49.735  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:58:49.735开始执行index
2020-04-29 11:58:49.803  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:58:49.803执行完成index
2020-04-29 11:58:49.803  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 11:58:51.612  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:58:51.612开始执行getContent
2020-04-29 11:58:51.654  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:58:51.654执行完成getContent
2020-04-29 11:58:51.655  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:39.679  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:59:39.679开始执行getContent
2020-04-29 11:59:39.716  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T11:59:39.716执行完成getContent
2020-04-29 11:59:39.716  INFO 21108 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:39.909  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:59:39.909开始执行getContent
2020-04-29 11:59:39.946  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T11:59:39.946执行完成getContent
2020-04-29 11:59:39.946  INFO 21108 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:40.142  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.142开始执行getContent
2020-04-29 11:59:40.179  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.179执行完成getContent
2020-04-29 11:59:40.179  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:40.385  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.385开始执行getContent
2020-04-29 11:59:40.421  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.421执行完成getContent
2020-04-29 11:59:40.421  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:40.623  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.623开始执行getContent
2020-04-29 11:59:40.660  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.660执行完成getContent
2020-04-29 11:59:40.661  INFO 21108 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:40.847  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.847开始执行getContent
2020-04-29 11:59:40.886  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:59:40.886执行完成getContent
2020-04-29 11:59:40.887  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:41.082  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.082开始执行getContent
2020-04-29 11:59:41.118  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.118执行完成getContent
2020-04-29 11:59:41.118  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:41.281  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.281开始执行getContent
2020-04-29 11:59:41.317  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.317执行完成getContent
2020-04-29 11:59:41.317  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:41.512  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.512开始执行getContent
2020-04-29 11:59:41.547  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.547执行完成getContent
2020-04-29 11:59:41.548  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:41.750  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.750开始执行getContent
2020-04-29 11:59:41.787  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.787执行完成getContent
2020-04-29 11:59:41.787  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:41.991  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:59:41.991开始执行getContent
2020-04-29 11:59:42.027  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.027执行完成getContent
2020-04-29 11:59:42.027  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:42.242  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.242开始执行getContent
2020-04-29 11:59:42.279  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.279执行完成getContent
2020-04-29 11:59:42.279  INFO 21108 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:42.500  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.500开始执行getContent
2020-04-29 11:59:42.537  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.537执行完成getContent
2020-04-29 11:59:42.537  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:42.729  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.729开始执行getContent
2020-04-29 11:59:42.765  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.765执行完成getContent
2020-04-29 11:59:42.766  INFO 21108 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:42.961  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.961开始执行getContent
2020-04-29 11:59:42.998  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:59:42.998执行完成getContent
2020-04-29 11:59:42.998  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:43.195  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:59:43.195开始执行getContent
2020-04-29 11:59:43.232  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T11:59:43.232执行完成getContent
2020-04-29 11:59:43.232  INFO 21108 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:51.399  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:51.399开始执行getContent
2020-04-29 11:59:51.435  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T11:59:51.435执行完成getContent
2020-04-29 11:59:51.436  INFO 21108 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:51.612  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:59:51.612开始执行getContent
2020-04-29 11:59:51.649  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T11:59:51.649执行完成getContent
2020-04-29 11:59:51.649  INFO 21108 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:51.831  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:59:51.831开始执行getContent
2020-04-29 11:59:51.867  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T11:59:51.867执行完成getContent
2020-04-29 11:59:51.867  INFO 21108 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 11:59:57.645  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:59:57.645开始执行getContent
2020-04-29 11:59:57.681  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T11:59:57.681执行完成getContent
2020-04-29 11:59:57.682  INFO 21108 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:00:37.085  INFO 6016 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 6016 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 12:00:37.087  INFO 6016 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 12:00:41.310  WARN 6016 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 12:00:41.720  INFO 6016 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 5.034 seconds (JVM running for 5.978)
2020-04-29 12:00:47.214  WARN 6016 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
2020-04-29 12:00:47.237  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:00:47.236开始执行count
2020-04-29 12:00:47.349  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:00:47.349执行完成count
2020-04-29 12:00:47.349  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:00:47.364  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:00:47.364开始执行index
2020-04-29 12:00:47.464  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:00:47.464执行完成index
2020-04-29 12:00:47.464  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:01:03.838  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:01:03.838开始执行count
2020-04-29 12:01:03.872  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:01:03.872执行完成count
2020-04-29 12:01:03.872  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:01:03.877  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:01:03.877开始执行index
2020-04-29 12:01:03.946  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:01:03.946执行完成index
2020-04-29 12:01:03.946  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:01:37.520  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:01:37.520开始执行count
2020-04-29 12:01:37.570  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:01:37.570执行完成count
2020-04-29 12:01:37.570  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:01:37.583  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:01:37.583开始执行index
2020-04-29 12:01:37.657  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:01:37.657执行完成index
2020-04-29 12:01:37.657  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:02:21.519  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:02:21.519开始执行count
2020-04-29 12:02:21.553  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:02:21.553执行完成count
2020-04-29 12:02:21.553  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:02:21.562  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:02:21.562开始执行index
2020-04-29 12:02:21.633  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:02:21.633执行完成index
2020-04-29 12:02:21.633  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:03:20.907  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:03:20.907开始执行count
2020-04-29 12:03:20.949  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:03:20.949执行完成count
2020-04-29 12:03:20.950  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:03:20.955  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:03:20.955开始执行index
2020-04-29 12:03:21.024  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:03:21.024执行完成index
2020-04-29 12:03:21.024  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:03:29.033  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:03:29.033开始执行count
2020-04-29 12:03:29.068  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:03:29.068执行完成count
2020-04-29 12:03:29.068  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:03:29.073  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:03:29.073开始执行index
2020-04-29 12:03:29.142  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:03:29.142执行完成index
2020-04-29 12:03:29.142  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:07:07.369  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:07:07.369开始执行count
2020-04-29 12:07:07.438  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:07:07.438执行完成count
2020-04-29 12:07:07.439  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:07:07.464  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:07:07.464开始执行index
2020-04-29 12:07:07.541  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:07:07.541执行完成index
2020-04-29 12:07:07.542  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:07:08.287  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:07:08.287开始执行count
2020-04-29 12:07:08.322  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:07:08.322执行完成count
2020-04-29 12:07:08.323  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:07:08.334  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:07:08.334开始执行index
2020-04-29 12:07:08.410  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:07:08.410执行完成index
2020-04-29 12:07:08.410  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:07:27.310  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:07:27.310开始执行count
2020-04-29 12:07:27.345  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:07:27.345执行完成count
2020-04-29 12:07:27.346  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:07:27.353  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:07:27.353开始执行index
2020-04-29 12:07:27.420  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:07:27.420执行完成index
2020-04-29 12:07:27.420  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:07:28.098  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:07:28.098开始执行count
2020-04-29 12:07:28.134  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:07:28.134执行完成count
2020-04-29 12:07:28.134  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:07:28.142  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:07:28.142开始执行index
2020-04-29 12:07:28.212  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:07:28.212执行完成index
2020-04-29 12:07:28.213  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:07:29.085  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:07:29.085开始执行count
2020-04-29 12:07:29.119  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:07:29.119执行完成count
2020-04-29 12:07:29.120  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:07:29.126  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:07:29.125开始执行index
2020-04-29 12:07:29.190  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:07:29.190执行完成index
2020-04-29 12:07:29.190  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:07:49.379  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:07:49.379开始执行count
2020-04-29 12:07:49.413  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:07:49.413执行完成count
2020-04-29 12:07:49.413  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:07:49.427  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:07:49.427开始执行index
2020-04-29 12:07:49.494  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:07:49.494执行完成index
2020-04-29 12:07:49.495  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:08:01.088  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:08:01.088开始执行count
2020-04-29 12:08:01.124  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:08:01.124执行完成count
2020-04-29 12:08:01.124  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:08:01.151  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:08:01.151开始执行index
2020-04-29 12:08:01.227  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:08:01.227执行完成index
2020-04-29 12:08:01.227  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:08:22.490  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:08:22.490开始执行count
2020-04-29 12:08:22.524  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:08:22.524执行完成count
2020-04-29 12:08:22.524  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:08:22.529  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:08:22.529开始执行index
2020-04-29 12:08:22.606  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:08:22.606执行完成index
2020-04-29 12:08:22.606  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:08:46.647  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:08:46.647开始执行count
2020-04-29 12:08:46.681  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:08:46.681执行完成count
2020-04-29 12:08:46.681  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:08:46.687  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:08:46.687开始执行index
2020-04-29 12:08:46.756  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:08:46.756执行完成index
2020-04-29 12:08:46.756  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:09:43.373  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:09:43.373开始执行count
2020-04-29 12:09:43.407  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:09:43.407执行完成count
2020-04-29 12:09:43.407  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:09:43.412  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:09:43.412开始执行index
2020-04-29 12:09:43.479  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:09:43.479执行完成index
2020-04-29 12:09:43.479  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:09:54.190  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:09:54.190开始执行count
2020-04-29 12:09:54.225  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:09:54.225执行完成count
2020-04-29 12:09:54.225  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:09:54.230  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:09:54.230开始执行index
2020-04-29 12:09:54.297  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:09:54.297执行完成index
2020-04-29 12:09:54.297  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:10:23.492  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:10:23.492开始执行count
2020-04-29 12:10:23.527  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:10:23.527执行完成count
2020-04-29 12:10:23.528  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:10:23.533  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:10:23.533开始执行index
2020-04-29 12:10:23.599  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:10:23.599执行完成index
2020-04-29 12:10:23.599  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:10:24.295  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.295开始执行count
2020-04-29 12:10:24.330  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.330执行完成count
2020-04-29 12:10:24.330  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:10:24.337  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.337开始执行index
2020-04-29 12:10:24.404  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.404执行完成index
2020-04-29 12:10:24.405  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:10:24.619  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.619开始执行count
2020-04-29 12:10:24.651  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.651执行完成count
2020-04-29 12:10:24.651  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:10:24.656  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.656开始执行index
2020-04-29 12:10:24.722  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.722执行完成index
2020-04-29 12:10:24.722  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:10:24.870  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.870开始执行count
2020-04-29 12:10:24.905  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.905执行完成count
2020-04-29 12:10:24.905  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:10:24.910  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.910开始执行index
2020-04-29 12:10:24.977  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:10:24.977执行完成index
2020-04-29 12:10:24.977  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:10:25.047  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:10:25.047开始执行count
2020-04-29 12:10:25.081  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:10:25.081执行完成count
2020-04-29 12:10:25.081  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:10:25.087  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:10:25.087开始执行index
2020-04-29 12:10:25.165  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:10:25.165执行完成index
2020-04-29 12:10:25.166  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:10:37.088  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:10:37.088开始执行count
2020-04-29 12:10:37.122  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:10:37.122执行完成count
2020-04-29 12:10:37.122  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:10:37.128  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:10:37.128开始执行index
2020-04-29 12:10:37.193  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:10:37.193执行完成index
2020-04-29 12:10:37.193  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:10:37.947  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:10:37.947开始执行count
2020-04-29 12:10:37.980  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:10:37.980执行完成count
2020-04-29 12:10:37.981  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:10:37.986  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:10:37.986开始执行index
2020-04-29 12:10:38.052  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:10:38.052执行完成index
2020-04-29 12:10:38.052  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:15:16.971  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:15:16.971开始执行count
2020-04-29 12:15:17.273  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:15:17.273开始执行count
2020-04-29 12:15:17.858  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:15:17.858开始执行count
2020-04-29 12:15:18.893  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:15:18.892执行完成count
2020-04-29 12:15:18.893  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:15:18.899  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:15:18.899开始执行index
2020-04-29 12:15:18.964  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:15:18.964执行完成index
2020-04-29 12:15:18.964  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:15:19.012  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:15:19.012执行完成count
2020-04-29 12:15:19.013  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:15:19.309  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:15:19.309执行完成count
2020-04-29 12:15:19.309  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:15:47.761  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:15:47.761开始执行count
2020-04-29 12:15:47.795  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:15:47.795执行完成count
2020-04-29 12:15:47.796  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:15:47.800  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:15:47.800开始执行index
2020-04-29 12:15:47.868  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:15:47.868执行完成index
2020-04-29 12:15:47.868  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:15:57.964  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:15:57.964开始执行index
2020-04-29 12:15:58.032  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:15:58.032执行完成index
2020-04-29 12:15:58.032  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:16:00.781  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:16:00.781开始执行index
2020-04-29 12:16:00.848  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:16:00.848执行完成index
2020-04-29 12:16:00.848  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:19:21.707  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:19:21.707开始执行getContent
2020-04-29 12:19:21.811  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:19:21.811执行完成getContent
2020-04-29 12:19:21.812  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:21:04.734  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:21:04.734开始执行count
2020-04-29 12:21:04.803  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:21:04.803执行完成count
2020-04-29 12:21:04.803  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:21:04.807  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:21:04.807开始执行index
2020-04-29 12:21:04.873  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:21:04.873执行完成index
2020-04-29 12:21:04.873  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:21:51.742  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:21:51.742开始执行count
2020-04-29 12:21:51.781  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:21:51.781执行完成count
2020-04-29 12:21:51.781  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:21:51.785  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:21:51.785开始执行index
2020-04-29 12:21:51.852  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:21:51.852执行完成index
2020-04-29 12:21:51.852  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:21:53.100  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:21:53.100开始执行count
2020-04-29 12:21:53.135  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:21:53.134执行完成count
2020-04-29 12:21:53.135  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:21:53.139  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:21:53.138开始执行index
2020-04-29 12:21:53.206  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:21:53.206执行完成index
2020-04-29 12:21:53.207  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:22:10.030  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:22:10.030开始执行getContent
2020-04-29 12:22:10.065  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:22:10.065执行完成getContent
2020-04-29 12:22:10.065  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=<p>开始动笔把</p>
)}]
2020-04-29 12:22:17.849  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:22:17.849开始执行count
2020-04-29 12:22:17.883  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:22:17.883执行完成count
2020-04-29 12:22:17.883  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:22:17.887  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:22:17.887开始执行index
2020-04-29 12:22:17.954  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:22:17.954执行完成index
2020-04-29 12:22:17.954  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:22:34.584  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:22:34.584开始执行getContent
2020-04-29 12:22:34.619  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:22:34.619执行完成getContent
2020-04-29 12:22:34.620  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:23:12.690  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:23:12.690开始执行count
2020-04-29 12:23:12.725  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:23:12.725执行完成count
2020-04-29 12:23:12.725  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:12.727  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:23:12.727开始执行index
2020-04-29 12:23:12.795  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:23:12.795执行完成index
2020-04-29 12:23:12.795  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:13.760  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:23:13.760开始执行count
2020-04-29 12:23:13.796  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:23:13.796执行完成count
2020-04-29 12:23:13.796  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:13.800  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:23:13.800开始执行index
2020-04-29 12:23:13.866  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:23:13.866执行完成index
2020-04-29 12:23:13.866  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:14.452  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.452开始执行count
2020-04-29 12:23:14.487  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.487执行完成count
2020-04-29 12:23:14.487  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:14.491  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.491开始执行index
2020-04-29 12:23:14.558  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.558执行完成index
2020-04-29 12:23:14.558  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:14.654  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.654开始执行count
2020-04-29 12:23:14.688  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.688执行完成count
2020-04-29 12:23:14.688  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:14.692  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.692开始执行index
2020-04-29 12:23:14.769  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.769执行完成index
2020-04-29 12:23:14.770  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:14.880  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.880开始执行count
2020-04-29 12:23:14.914  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.914执行完成count
2020-04-29 12:23:14.914  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:14.918  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.918开始执行index
2020-04-29 12:23:14.998  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:23:14.998执行完成index
2020-04-29 12:23:14.998  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:15.105  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.105开始执行count
2020-04-29 12:23:15.139  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.139执行完成count
2020-04-29 12:23:15.139  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:15.143  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.143开始执行index
2020-04-29 12:23:15.220  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.220执行完成index
2020-04-29 12:23:15.221  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:15.326  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.326开始执行count
2020-04-29 12:23:15.363  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.363执行完成count
2020-04-29 12:23:15.363  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:15.371  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.370开始执行index
2020-04-29 12:23:15.453  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:23:15.453执行完成index
2020-04-29 12:23:15.453  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:23.887  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:23:23.887开始执行count
2020-04-29 12:23:23.920  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:23:23.920执行完成count
2020-04-29 12:23:23.920  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:23.925  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:23:23.925开始执行index
2020-04-29 12:23:23.991  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:23:23.991执行完成index
2020-04-29 12:23:23.992  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:27.643  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:23:27.643开始执行index
2020-04-29 12:23:27.711  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:23:27.711执行完成index
2020-04-29 12:23:27.711  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:30.365  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:23:30.365开始执行index
2020-04-29 12:23:30.434  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:23:30.434执行完成index
2020-04-29 12:23:30.434  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:23:58.961  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:23:58.961开始执行count
2020-04-29 12:23:58.998  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:23:58.998执行完成count
2020-04-29 12:23:58.998  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:23:59.002  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:23:59.002开始执行index
2020-04-29 12:23:59.070  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:23:59.070执行完成index
2020-04-29 12:23:59.071  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:24:07.865  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:24:07.865开始执行count
2020-04-29 12:24:07.899  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:24:07.899执行完成count
2020-04-29 12:24:07.899  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:24:07.904  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:24:07.904开始执行index
2020-04-29 12:24:07.970  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:24:07.970执行完成index
2020-04-29 12:24:07.970  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:25:21.489  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:25:21.489开始执行count
2020-04-29 12:25:21.556  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:25:21.556执行完成count
2020-04-29 12:25:21.556  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:25:21.560  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:25:21.560开始执行index
2020-04-29 12:25:21.627  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:25:21.627执行完成index
2020-04-29 12:25:21.627  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:25:55.357  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.356开始执行count
2020-04-29 12:25:55.391  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.391执行完成count
2020-04-29 12:25:55.391  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:25:55.395  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.395开始执行index
2020-04-29 12:25:55.461  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.461执行完成index
2020-04-29 12:25:55.461  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:25:55.601  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.601开始执行count
2020-04-29 12:25:55.635  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.635执行完成count
2020-04-29 12:25:55.635  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:25:55.641  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.640开始执行index
2020-04-29 12:25:55.709  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.709执行完成index
2020-04-29 12:25:55.709  INFO 6016 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:25:55.895  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.895开始执行count
2020-04-29 12:25:55.929  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.929执行完成count
2020-04-29 12:25:55.929  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:25:55.933  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:25:55.933开始执行index
2020-04-29 12:25:56.004  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:25:56.004执行完成index
2020-04-29 12:25:56.004  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:27:37.717  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:27:37.717开始执行count
2020-04-29 12:27:37.789  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:27:37.789执行完成count
2020-04-29 12:27:37.789  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:27:37.813  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:27:37.813开始执行index
2020-04-29 12:27:37.881  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:27:37.881执行完成index
2020-04-29 12:27:37.881  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:27:41.390  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.390开始执行count
2020-04-29 12:27:41.425  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.425执行完成count
2020-04-29 12:27:41.425  INFO 6016 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:27:41.428  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.428开始执行index
2020-04-29 12:27:41.495  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.495执行完成index
2020-04-29 12:27:41.495  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:27:41.817  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.817开始执行count
2020-04-29 12:27:41.851  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.851执行完成count
2020-04-29 12:27:41.851  INFO 6016 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:27:41.854  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.854开始执行index
2020-04-29 12:27:41.922  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:27:41.922执行完成index
2020-04-29 12:27:41.922  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:27:42.596  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:27:42.596开始执行count
2020-04-29 12:27:42.630  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:27:42.630执行完成count
2020-04-29 12:27:42.631  INFO 6016 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:27:42.634  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:27:42.634开始执行index
2020-04-29 12:27:42.701  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:27:42.701执行完成index
2020-04-29 12:27:42.701  INFO 6016 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:29:12.947 ERROR 6016 --- [http-nio-80-exec-4] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-4] Exception processing template "about": An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:239) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: (Line = 47, Column = 47) Malformed markup: Attribute "class" appears more than once in element
	at org.attoparser.MarkupEventProcessorHandler.handleAttribute(MarkupEventProcessorHandler.java:549) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingAttributeSequenceUtil.parseAttributeSequence(ParsingAttributeSequenceUtil.java:275) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:153) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted

2020-04-29 12:29:12.951 ERROR 6016 --- [http-nio-80-exec-4] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)] with root cause

org.attoparser.ParseException: (Line = 47, Column = 47) Malformed markup: Attribute "class" appears more than once in element
	at org.attoparser.MarkupEventProcessorHandler.handleAttribute(MarkupEventProcessorHandler.java:549) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingAttributeSequenceUtil.parseAttributeSequence(ParsingAttributeSequenceUtil.java:275) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:153) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 12:29:14.990  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:29:14.990开始执行count
2020-04-29 12:29:15.059  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:29:15.059执行完成count
2020-04-29 12:29:15.059  INFO 6016 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:29:15.064  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:29:15.064开始执行index
2020-04-29 12:29:15.130  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:29:15.129执行完成index
2020-04-29 12:29:15.130  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:29:15.948  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:29:15.948开始执行count
2020-04-29 12:29:15.983  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:29:15.983执行完成count
2020-04-29 12:29:15.983  INFO 6016 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:29:15.987  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:29:15.987开始执行index
2020-04-29 12:29:16.053  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:29:16.053执行完成index
2020-04-29 12:29:16.053  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:29:16.603 ERROR 6016 --- [http-nio-80-exec-2] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-2] Exception processing template "about": An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:239) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: (Line = 47, Column = 47) Malformed markup: Attribute "class" appears more than once in element
	at org.attoparser.MarkupEventProcessorHandler.handleAttribute(MarkupEventProcessorHandler.java:549) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingAttributeSequenceUtil.parseAttributeSequence(ParsingAttributeSequenceUtil.java:275) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:153) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted

2020-04-29 12:29:16.604 ERROR 6016 --- [http-nio-80-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)] with root cause

org.attoparser.ParseException: (Line = 47, Column = 47) Malformed markup: Attribute "class" appears more than once in element
	at org.attoparser.MarkupEventProcessorHandler.handleAttribute(MarkupEventProcessorHandler.java:549) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingAttributeSequenceUtil.parseAttributeSequence(ParsingAttributeSequenceUtil.java:275) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:153) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 12:29:42.862 ERROR 6016 --- [http-nio-80-exec-10] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-10] Exception processing template "about": An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:239) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: (Line = 47, Column = 47) Malformed markup: Attribute "class" appears more than once in element
	at org.attoparser.MarkupEventProcessorHandler.handleAttribute(MarkupEventProcessorHandler.java:549) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingAttributeSequenceUtil.parseAttributeSequence(ParsingAttributeSequenceUtil.java:275) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:153) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted

2020-04-29 12:29:42.869 ERROR 6016 --- [http-nio-80-exec-10] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/about.html]" - line 47, col 47)] with root cause

org.attoparser.ParseException: (Line = 47, Column = 47) Malformed markup: Attribute "class" appears more than once in element
	at org.attoparser.MarkupEventProcessorHandler.handleAttribute(MarkupEventProcessorHandler.java:549) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingAttributeSequenceUtil.parseAttributeSequence(ParsingAttributeSequenceUtil.java:275) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:153) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 12:30:46.623  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:30:46.623开始执行count
2020-04-29 12:30:46.692  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:30:46.692执行完成count
2020-04-29 12:30:46.692  INFO 6016 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:30:46.698  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:30:46.698开始执行index
2020-04-29 12:30:46.764  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:30:46.764执行完成index
2020-04-29 12:30:46.764  INFO 6016 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:31:03.023  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:31:03.023开始执行getContent
2020-04-29 12:31:03.058  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:31:03.058执行完成getContent
2020-04-29 12:31:03.058  INFO 6016 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:39:51.962  INFO 8956 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 8956 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 12:39:51.964  INFO 8956 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 12:39:57.448  WARN 8956 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 12:39:58.026  INFO 8956 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 6.754 seconds (JVM running for 7.734)
2020-04-29 12:40:02.385  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:40:02.383开始执行count
2020-04-29 12:40:02.528  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:40:02.528执行完成count
2020-04-29 12:40:02.528  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:40:02.555  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:40:02.555开始执行index
2020-04-29 12:40:02.695  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:40:02.695执行完成index
2020-04-29 12:40:02.700  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:40:04.080  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:40:04.080开始执行getContent
2020-04-29 12:40:04.148  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:40:04.148执行完成getContent
2020-04-29 12:40:04.148  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:40:06.934  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:40:06.934开始执行getContent
2020-04-29 12:40:06.970  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:40:06.970执行完成getContent
2020-04-29 12:40:06.970  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:40:15.684  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:40:15.684开始执行getContent
2020-04-29 12:40:15.720  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:40:15.720执行完成getContent
2020-04-29 12:40:15.720  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:40:27.545  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:40:27.545开始执行getContent
2020-04-29 12:40:27.583  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:40:27.583执行完成getContent
2020-04-29 12:40:27.583  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:41:44.592  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:41:44.592开始执行count
2020-04-29 12:41:44.660  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:41:44.660执行完成count
2020-04-29 12:41:44.660  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:41:44.671  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:41:44.671开始执行index
2020-04-29 12:41:44.739  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:41:44.739执行完成index
2020-04-29 12:41:44.740  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:42:40.650  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:42:40.649开始执行count
2020-04-29 12:42:40.684  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:42:40.684执行完成count
2020-04-29 12:42:40.684  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 12:42:40.693  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:42:40.693开始执行index
2020-04-29 12:42:40.762  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:42:40.762执行完成index
2020-04-29 12:42:40.763  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 12:42:43.415  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:42:43.415开始执行getContent
2020-04-29 12:42:43.450  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:42:43.450执行完成getContent
2020-04-29 12:42:43.450  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:43:14.951  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:43:14.951开始执行getContent
2020-04-29 12:43:14.988  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:43:14.988执行完成getContent
2020-04-29 12:43:14.988  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:43:15.706  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:43:15.706开始执行getContent
2020-04-29 12:43:15.741  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:43:15.741执行完成getContent
2020-04-29 12:43:15.742  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:43:15.928  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:43:15.928开始执行getContent
2020-04-29 12:43:15.972  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:43:15.972执行完成getContent
2020-04-29 12:43:15.972  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:43:16.349  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:43:16.349开始执行getContent
2020-04-29 12:43:16.389  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:43:16.389执行完成getContent
2020-04-29 12:43:16.389  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:43:16.577  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:43:16.577开始执行getContent
2020-04-29 12:43:16.614  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:43:16.614执行完成getContent
2020-04-29 12:43:16.615  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:43:49.655  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:43:49.655开始执行getContent
2020-04-29 12:43:49.690  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:43:49.690执行完成getContent
2020-04-29 12:43:49.690  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:44:03.570  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:44:03.570开始执行getContent
2020-04-29 12:44:03.604  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:44:03.604执行完成getContent
2020-04-29 12:44:03.605  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:44:03.848  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:44:03.848开始执行getContent
2020-04-29 12:44:03.885  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:44:03.885执行完成getContent
2020-04-29 12:44:03.885  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:44:22.483  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:44:22.483开始执行getContent
2020-04-29 12:44:22.517  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:44:22.517执行完成getContent
2020-04-29 12:44:22.518  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:44:22.705  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:44:22.705开始执行getContent
2020-04-29 12:44:22.740  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:44:22.740执行完成getContent
2020-04-29 12:44:22.740  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:44:22.990  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:44:22.990开始执行getContent
2020-04-29 12:44:23.025  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:44:23.025执行完成getContent
2020-04-29 12:44:23.025  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:44:59.061  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:44:59.061开始执行getContent
2020-04-29 12:44:59.097  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:44:59.097执行完成getContent
2020-04-29 12:44:59.097  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:45:30.035  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:45:30.035开始执行getContent
2020-04-29 12:45:30.070  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:45:30.070执行完成getContent
2020-04-29 12:45:30.070  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:45:36.671  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:45:36.671开始执行getContent
2020-04-29 12:45:36.706  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:45:36.706执行完成getContent
2020-04-29 12:45:36.706  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:46:46.057  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:46:46.057开始执行getContent
2020-04-29 12:46:46.124  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:46:46.124执行完成getContent
2020-04-29 12:46:46.124  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:46:46.363  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
2020-04-29 12:47:00.378  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:47:00.378开始执行getContent
2020-04-29 12:47:00.416  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:47:00.416执行完成getContent
2020-04-29 12:47:00.416  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:47:02.788  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
2020-04-29 12:48:13.753  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:48:13.753开始执行getContent
2020-04-29 12:48:13.822  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:48:13.822执行完成getContent
2020-04-29 12:48:13.823  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:48:14.592  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
2020-04-29 12:48:53.029  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:48:53.029开始执行getContent
2020-04-29 12:48:53.063  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:48:53.063执行完成getContent
2020-04-29 12:48:53.063  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:49:09.019  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:49:09.019开始执行getContent
2020-04-29 12:49:09.053  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:49:09.053执行完成getContent
2020-04-29 12:49:09.053  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:49:47.820  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:49:47.820开始执行getContent
2020-04-29 12:49:47.859  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:49:47.859执行完成getContent
2020-04-29 12:49:47.859  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:49:49.804  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
2020-04-29 12:50:44.615  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:50:44.615开始执行getContent
2020-04-29 12:50:44.650  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:50:44.650执行完成getContent
2020-04-29 12:50:44.650  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:50:45.418  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:50:45.418开始执行getContent
2020-04-29 12:50:45.451  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:50:45.451执行完成getContent
2020-04-29 12:50:45.451  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:50:54.534  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:50:54.534开始执行getContent
2020-04-29 12:50:54.568  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:50:54.568执行完成getContent
2020-04-29 12:50:54.568  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:50:54.819  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:50:54.819开始执行getContent
2020-04-29 12:50:54.853  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:50:54.853执行完成getContent
2020-04-29 12:50:54.853  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:50:55.415  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:50:55.415开始执行getContent
2020-04-29 12:50:55.449  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:50:55.449执行完成getContent
2020-04-29 12:50:55.449  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:52:20.379  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:52:20.379开始执行getContent
2020-04-29 12:52:20.445  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T12:52:20.445执行完成getContent
2020-04-29 12:52:20.445  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:52:51.151  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:52:51.151开始执行getContent
2020-04-29 12:52:51.185  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T12:52:51.185执行完成getContent
2020-04-29 12:52:51.186  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:53:05.043  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:53:05.043开始执行getContent
2020-04-29 12:53:05.083  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:53:05.083执行完成getContent
2020-04-29 12:53:05.084  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:54:22.737  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:54:22.737开始执行getContent
2020-04-29 12:54:22.804  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:54:22.804执行完成getContent
2020-04-29 12:54:22.804  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:54:39.824  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:54:39.824开始执行getContent
2020-04-29 12:54:39.858  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:54:39.858执行完成getContent
2020-04-29 12:54:39.858  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:54:40.069  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:54:40.069开始执行getContent
2020-04-29 12:54:40.103  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:54:40.103执行完成getContent
2020-04-29 12:54:40.103  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:54:57.928  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:54:57.928开始执行getContent
2020-04-29 12:54:57.961  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T12:54:57.961执行完成getContent
2020-04-29 12:54:57.961  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:57:56.928  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:57:56.928开始执行getContent
2020-04-29 12:57:57.004  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:57:57.003执行完成getContent
2020-04-29 12:57:57.004  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:58:18.323  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:58:18.323开始执行getContent
2020-04-29 12:58:18.357  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T12:58:18.357执行完成getContent
2020-04-29 12:58:18.357  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:58:18.538  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:58:18.538开始执行getContent
2020-04-29 12:58:18.573  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:58:18.573执行完成getContent
2020-04-29 12:58:18.573  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:58:28.382  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:58:28.382开始执行getContent
2020-04-29 12:58:28.416  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T12:58:28.416执行完成getContent
2020-04-29 12:58:28.416  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:59:08.735  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:59:08.735开始执行getContent
2020-04-29 12:59:08.771  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:59:08.771执行完成getContent
2020-04-29 12:59:08.771  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:59:09.422  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:59:09.421开始执行getContent
2020-04-29 12:59:09.456  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T12:59:09.456执行完成getContent
2020-04-29 12:59:09.456  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:59:10.087  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:59:10.087开始执行getContent
2020-04-29 12:59:10.120  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T12:59:10.120执行完成getContent
2020-04-29 12:59:10.121  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:59:23.470  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:59:23.470开始执行getContent
2020-04-29 12:59:23.503  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T12:59:23.503执行完成getContent
2020-04-29 12:59:23.503  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:59:24.180  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:59:24.180开始执行getContent
2020-04-29 12:59:24.215  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T12:59:24.215执行完成getContent
2020-04-29 12:59:24.215  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 12:59:24.628  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:59:24.628开始执行getContent
2020-04-29 12:59:24.662  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T12:59:24.662执行完成getContent
2020-04-29 12:59:24.662  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:01:14.385  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:01:14.385开始执行getContent
2020-04-29 13:01:14.462  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:01:14.462执行完成getContent
2020-04-29 13:01:14.463  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:01:15.069  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:01:15.069开始执行getContent
2020-04-29 13:01:15.107  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:01:15.107执行完成getContent
2020-04-29 13:01:15.107  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:01:31.517  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:01:31.517开始执行getContent
2020-04-29 13:01:31.553  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:01:31.553执行完成getContent
2020-04-29 13:01:31.553  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:02:13.092  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:02:13.092开始执行getContent
2020-04-29 13:02:13.126  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:02:13.126执行完成getContent
2020-04-29 13:02:13.127  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:02:13.748  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:02:13.748开始执行getContent
2020-04-29 13:02:13.783  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:02:13.783执行完成getContent
2020-04-29 13:02:13.783  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:02:14.050  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:02:14.050开始执行getContent
2020-04-29 13:02:14.082  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:02:14.082执行完成getContent
2020-04-29 13:02:14.082  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:02:14.287  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:02:14.287开始执行getContent
2020-04-29 13:02:14.321  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:02:14.321执行完成getContent
2020-04-29 13:02:14.321  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:03:21.840  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:03:21.840开始执行getContent
2020-04-29 13:03:21.905  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:03:21.905执行完成getContent
2020-04-29 13:03:21.905  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:03:34.101  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:03:34.101开始执行getContent
2020-04-29 13:03:34.136  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:03:34.136执行完成getContent
2020-04-29 13:03:34.136  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:03:47.538  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:03:47.538开始执行getContent
2020-04-29 13:03:47.572  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:03:47.572执行完成getContent
2020-04-29 13:03:47.572  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:04:53.925  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:04:53.925开始执行getContent
2020-04-29 13:04:53.991  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:04:53.991执行完成getContent
2020-04-29 13:04:53.991  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:05:16.746  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:05:16.746开始执行getContent
2020-04-29 13:05:16.780  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:05:16.780执行完成getContent
2020-04-29 13:05:16.780  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:05:45.363  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:05:45.362开始执行getContent
2020-04-29 13:05:45.396  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:05:45.396执行完成getContent
2020-04-29 13:05:45.396  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:06:01.699  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:06:01.699开始执行getContent
2020-04-29 13:06:01.732  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:06:01.732执行完成getContent
2020-04-29 13:06:01.733  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:07:17.467  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:07:17.467开始执行getContent
2020-04-29 13:07:17.534  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:07:17.534执行完成getContent
2020-04-29 13:07:17.534  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:07:17.879  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:07:17.879开始执行getContent
2020-04-29 13:07:17.912  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:07:17.912执行完成getContent
2020-04-29 13:07:17.912  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:07:42.895  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:07:42.895开始执行getContent
2020-04-29 13:07:42.930  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:07:42.930执行完成getContent
2020-04-29 13:07:42.930  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:07:57.699  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:07:57.699开始执行getContent
2020-04-29 13:07:57.733  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:07:57.733执行完成getContent
2020-04-29 13:07:57.733  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:09:28.295  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:09:28.295开始执行getContent
2020-04-29 13:09:28.363  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:09:28.363执行完成getContent
2020-04-29 13:09:28.363  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:09:28.953  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:09:28.953开始执行getContent
2020-04-29 13:09:28.987  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:09:28.987执行完成getContent
2020-04-29 13:09:28.987  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:11:00.412  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:11:00.412开始执行getContent
2020-04-29 13:11:00.479  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:11:00.478执行完成getContent
2020-04-29 13:11:00.479  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:11:00.486 ERROR 8956 --- [http-nio-80-exec-2] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-2] Exception processing template "content": An error happened during template parsing (template: "class path resource [templates/content.html]")

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]")
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: Exception evaluating SpringEL expression: "blog.user.nickname" (template: "content" - line 27, col 62)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted
Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Exception evaluating SpringEL expression: "blog.user.nickname" (template: "content" - line 27, col 62)
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:290) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	... 53 common frames omitted
Caused by: org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'user' cannot be found on object of type 'com.blog.bean.Blog' - maybe not public or not valid?
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:91) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:61) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:91) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 72 common frames omitted

2020-04-29 13:11:00.490 ERROR 8956 --- [http-nio-80-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]")] with root cause

org.springframework.expression.spel.SpelEvaluationException: EL1008E: Property or field 'user' cannot be found on object of type 'com.blog.bean.Blog' - maybe not public or not valid?
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.readProperty(PropertyOrFieldReference.java:217) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:104) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.PropertyOrFieldReference.getValueInternal(PropertyOrFieldReference.java:91) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueRef(CompoundExpression.java:61) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.CompoundExpression.getValueInternal(CompoundExpression.java:91) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:112) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.expression.spel.standard.SpelExpression.getValue(SpelExpression.java:337) ~[spring-expression-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.thymeleaf.spring5.expression.SPELVariableExpressionEvaluator.evaluate(SPELVariableExpressionEvaluator.java:263) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.VariableExpression.executeVariableExpression(VariableExpression.java:166) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.SimpleExpression.executeSimple(SimpleExpression.java:66) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:109) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.Expression.execute(Expression.java:138) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:144) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 13:11:40.957  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:11:40.957开始执行getContent
2020-04-29 13:11:40.991  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:11:40.991执行完成getContent
2020-04-29 13:11:40.991  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:11:40.993 ERROR 8956 --- [http-nio-80-exec-5] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-5] Exception processing template "content": An error happened during template parsing (template: "class path resource [templates/content.html]")

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]")
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: Could not parse as expression: "" (template: "content" - line 27, col 62)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted
Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: "" (template: "content" - line 27, col 62)
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:131) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:62) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:44) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.parseAttributeExpression(EngineEventUtils.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.computeAttributeExpression(EngineEventUtils.java:207) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:125) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	... 53 common frames omitted

2020-04-29 13:11:40.995 ERROR 8956 --- [http-nio-80-exec-5] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]")] with root cause

org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: "" (template: "content" - line 27, col 62)
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:131) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:62) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:44) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.parseAttributeExpression(EngineEventUtils.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.computeAttributeExpression(EngineEventUtils.java:207) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:125) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 13:11:41.866  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:11:41.866开始执行getContent
2020-04-29 13:11:41.900  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:11:41.900执行完成getContent
2020-04-29 13:11:41.900  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:11:41.902 ERROR 8956 --- [http-nio-80-exec-6] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-6] Exception processing template "content": An error happened during template parsing (template: "class path resource [templates/content.html]")

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]")
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:241) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: Could not parse as expression: "" (template: "content" - line 27, col 62)
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:393) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted
Caused by: org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: "" (template: "content" - line 27, col 62)
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:131) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:62) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:44) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.parseAttributeExpression(EngineEventUtils.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.computeAttributeExpression(EngineEventUtils.java:207) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:125) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	... 53 common frames omitted

2020-04-29 13:11:41.904 ERROR 8956 --- [http-nio-80-exec-6] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]")] with root cause

org.thymeleaf.exceptions.TemplateProcessingException: Could not parse as expression: "" (template: "content" - line 27, col 62)
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:131) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:62) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.expression.StandardExpressionParser.parseExpression(StandardExpressionParser.java:44) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.parseAttributeExpression(EngineEventUtils.java:220) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.EngineEventUtils.computeAttributeExpression(EngineEventUtils.java:207) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.processor.AbstractStandardExpressionAttributeTagProcessor.doProcess(AbstractStandardExpressionAttributeTagProcessor.java:125) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractAttributeTagProcessor.doProcess(AbstractAttributeTagProcessor.java:74) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.processor.element.AbstractElementTagProcessor.process(AbstractElementTagProcessor.java:95) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.util.ProcessorConfigurationUtils$ElementTagProcessorWrapper.process(ProcessorConfigurationUtils.java:633) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.ProcessorTemplateHandler.handleOpenElement(ProcessorTemplateHandler.java:1314) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateHandlerAdapterMarkupHandler.handleOpenElementEnd(TemplateHandlerAdapterMarkupHandler.java:304) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler$InlineMarkupAdapterPreProcessorHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:278) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.standard.inline.OutputExpressionInlinePreProcessorHandler.handleOpenElementEnd(OutputExpressionInlinePreProcessorHandler.java:186) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.InlinedOutputExpressionMarkupHandler.handleOpenElementEnd(InlinedOutputExpressionMarkupHandler.java:124) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.attoparser.HtmlElement.handleOpenElementEnd(HtmlElement.java:109) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.HtmlMarkupHandler.handleOpenElementEnd(HtmlMarkupHandler.java:297) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupEventProcessorHandler.handleOpenElementEnd(MarkupEventProcessorHandler.java:402) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.ParsingElementMarkupUtil.parseOpenElement(ParsingElementMarkupUtil.java:159) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseBuffer(MarkupParser.java:710) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:301) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 13:11:57.537  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:11:57.537开始执行getContent
2020-04-29 13:11:57.571  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:11:57.571执行完成getContent
2020-04-29 13:11:57.571  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:09.640  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:12:09.640开始执行getContent
2020-04-29 13:12:09.679  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:12:09.679执行完成getContent
2020-04-29 13:12:09.679  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:10.293  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:12:10.293开始执行getContent
2020-04-29 13:12:10.329  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:12:10.329执行完成getContent
2020-04-29 13:12:10.329  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:10.796  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:12:10.796开始执行getContent
2020-04-29 13:12:10.829  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:12:10.829执行完成getContent
2020-04-29 13:12:10.829  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:11.020  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:12:11.020开始执行getContent
2020-04-29 13:12:11.053  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:12:11.053执行完成getContent
2020-04-29 13:12:11.053  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:11.242  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:12:11.242开始执行getContent
2020-04-29 13:12:11.276  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:12:11.276执行完成getContent
2020-04-29 13:12:11.276  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:11.456  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:12:11.456开始执行getContent
2020-04-29 13:12:11.490  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:12:11.490执行完成getContent
2020-04-29 13:12:11.490  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:23.575  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:12:23.575开始执行getContent
2020-04-29 13:12:23.609  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:12:23.609执行完成getContent
2020-04-29 13:12:23.609  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:24.076  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.076开始执行getContent
2020-04-29 13:12:24.112  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.112执行完成getContent
2020-04-29 13:12:24.112  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:24.312  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.312开始执行getContent
2020-04-29 13:12:24.346  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.346执行完成getContent
2020-04-29 13:12:24.346  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:24.524  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.524开始执行getContent
2020-04-29 13:12:24.558  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.558执行完成getContent
2020-04-29 13:12:24.558  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:24.728  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.727开始执行getContent
2020-04-29 13:12:24.761  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:12:24.761执行完成getContent
2020-04-29 13:12:24.761  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:12:40.534  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:12:40.534开始执行getContent
2020-04-29 13:12:40.567  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:12:40.567执行完成getContent
2020-04-29 13:12:40.567  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:13:37.784  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:13:37.784开始执行getContent
2020-04-29 13:13:37.818  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:13:37.818执行完成getContent
2020-04-29 13:13:37.818  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:13:51.272  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:13:51.272开始执行getContent
2020-04-29 13:13:51.311  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:13:51.311执行完成getContent
2020-04-29 13:13:51.311  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:13:51.763  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:13:51.763开始执行getContent
2020-04-29 13:13:51.796  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:13:51.796执行完成getContent
2020-04-29 13:13:51.796  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:14:35.381  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:14:35.381开始执行getContent
2020-04-29 13:14:35.415  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:14:35.415执行完成getContent
2020-04-29 13:14:35.416  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:14:35.613  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:14:35.613开始执行getContent
2020-04-29 13:14:35.647  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:14:35.647执行完成getContent
2020-04-29 13:14:35.647  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:14:35.868  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:14:35.868开始执行getContent
2020-04-29 13:14:35.902  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:14:35.902执行完成getContent
2020-04-29 13:14:35.902  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:14:59.318  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:14:59.318开始执行getContent
2020-04-29 13:14:59.352  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:14:59.352执行完成getContent
2020-04-29 13:14:59.352  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:14:59.628  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:14:59.628开始执行getContent
2020-04-29 13:14:59.662  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:14:59.662执行完成getContent
2020-04-29 13:14:59.662  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:14:59.940  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:14:59.940开始执行getContent
2020-04-29 13:14:59.973  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:14:59.973执行完成getContent
2020-04-29 13:14:59.973  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:15:17.150  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:15:17.150开始执行getContent
2020-04-29 13:15:17.185  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:15:17.185执行完成getContent
2020-04-29 13:15:17.185  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:15:28.871  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:15:28.871开始执行getContent
2020-04-29 13:15:28.905  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:15:28.905执行完成getContent
2020-04-29 13:15:28.905  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:15:51.634  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:15:51.634开始执行getContent
2020-04-29 13:15:51.669  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:15:51.669执行完成getContent
2020-04-29 13:15:51.669  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:15:52.185  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.185开始执行getContent
2020-04-29 13:15:52.220  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.220执行完成getContent
2020-04-29 13:15:52.220  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:15:52.424  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.424开始执行getContent
2020-04-29 13:15:52.458  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.458执行完成getContent
2020-04-29 13:15:52.458  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:15:52.646  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.646开始执行getContent
2020-04-29 13:15:52.679  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.679执行完成getContent
2020-04-29 13:15:52.679  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:15:52.854  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.854开始执行getContent
2020-04-29 13:15:52.889  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:15:52.889执行完成getContent
2020-04-29 13:15:52.889  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:16:05.644  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:16:05.644开始执行getContent
2020-04-29 13:16:05.678  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:16:05.678执行完成getContent
2020-04-29 13:16:05.678  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:16:13.478  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:16:13.478开始执行getContent
2020-04-29 13:16:13.512  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:16:13.512执行完成getContent
2020-04-29 13:16:13.512  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:16:13.768  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:16:13.768开始执行getContent
2020-04-29 13:16:13.804  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:16:13.804执行完成getContent
2020-04-29 13:16:13.804  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:16:14.008  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:16:14.008开始执行getContent
2020-04-29 13:16:14.042  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:16:14.042执行完成getContent
2020-04-29 13:16:14.042  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:16:14.225  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:16:14.225开始执行getContent
2020-04-29 13:16:14.259  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:16:14.259执行完成getContent
2020-04-29 13:16:14.259  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:16:49.231  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:16:49.231开始执行getContent
2020-04-29 13:16:49.265  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:16:49.265执行完成getContent
2020-04-29 13:16:49.265  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:16:49.506  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:16:49.506开始执行getContent
2020-04-29 13:16:49.541  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:16:49.541执行完成getContent
2020-04-29 13:16:49.541  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:17:21.037  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:17:21.037开始执行getContent
2020-04-29 13:17:21.071  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:17:21.071执行完成getContent
2020-04-29 13:17:21.071  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:17:21.285  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:17:21.284开始执行getContent
2020-04-29 13:17:21.319  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:17:21.319执行完成getContent
2020-04-29 13:17:21.319  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:17:21.564  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:17:21.564开始执行getContent
2020-04-29 13:17:21.599  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:17:21.599执行完成getContent
2020-04-29 13:17:21.599  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:17:35.286  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:17:35.286开始执行getContent
2020-04-29 13:17:35.320  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:17:35.320执行完成getContent
2020-04-29 13:17:35.320  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:17:35.948  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:17:35.948开始执行getContent
2020-04-29 13:17:35.982  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:17:35.982执行完成getContent
2020-04-29 13:17:35.982  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:18:17.947  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:18:17.947开始执行getContent
2020-04-29 13:18:17.981  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:18:17.981执行完成getContent
2020-04-29 13:18:17.981  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:18:33.326  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:18:33.326开始执行getContent
2020-04-29 13:18:33.360  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:18:33.360执行完成getContent
2020-04-29 13:18:33.360  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:18:33.604  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:18:33.604开始执行getContent
2020-04-29 13:18:33.638  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:18:33.638执行完成getContent
2020-04-29 13:18:33.638  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:18:58.572  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:18:58.572开始执行getContent
2020-04-29 13:18:58.605  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:18:58.605执行完成getContent
2020-04-29 13:18:58.605  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:19:51.873  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:19:51.873开始执行count
2020-04-29 13:19:51.906  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:19:51.906执行完成count
2020-04-29 13:19:51.906  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:19:51.911  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:19:51.911开始执行index
2020-04-29 13:19:51.976  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:19:51.976执行完成index
2020-04-29 13:19:51.976  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:19:53.486  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:19:53.486开始执行getContent
2020-04-29 13:19:53.522  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:19:53.522执行完成getContent
2020-04-29 13:19:53.522  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:22:31.047  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:22:31.047开始执行getContent
2020-04-29 13:22:31.115  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:22:31.115执行完成getContent
2020-04-29 13:22:31.115  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:22:31.742  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:22:31.742开始执行getContent
2020-04-29 13:22:31.776  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:22:31.776执行完成getContent
2020-04-29 13:22:31.776  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:23:12.452  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:23:12.452开始执行getContent
2020-04-29 13:23:12.487  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:23:12.487执行完成getContent
2020-04-29 13:23:12.487  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:23:55.589  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:23:55.589开始执行getContent
2020-04-29 13:23:55.623  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:23:55.623执行完成getContent
2020-04-29 13:23:55.623  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:24:18.774  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:24:18.774开始执行getContent
2020-04-29 13:24:18.808  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:24:18.808执行完成getContent
2020-04-29 13:24:18.808  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:25:19.283  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:25:19.283开始执行getContent
2020-04-29 13:25:19.349  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:25:19.349执行完成getContent
2020-04-29 13:25:19.349  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:25:19.351 ERROR 8956 --- [http-nio-80-exec-9] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-9] Exception processing template "content": An error happened during template parsing (template: "class path resource [templates/content.html]" - line 28, col 45)

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]" - line 28, col 45)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:239) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: (Line = 28, Column = 45) Incomplete structure: "<li th:if="  th:if="${session.user!=null}">
                                                <div id="test4"></div>
                                            </li>
                                        </ul>
                                    </div>
                                    <div style="float: right;">
                                        <img style="width:90px" src="/static/img/wx.png">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="layui-col-md3 margin-top" style="position:fixed;top: 10%;right: 5%;">
                    <div class="layui-card">
                        <div class="layui-card-header">百科</div>
                        <div class="layui-card-body">
                           <input type="text" id="baidu" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content"></div>
                        </div>
                </div>
                    <div class="layui-card">
                        <div class="layui-card-header">翻译</div>
                        <div class="layui-card-body">
                            <input type="text" id="translate" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content1"></div>
                        </div>
                    </div>
                    <div class="layui-card">
                        <div class="layui-card-header">阅读工具</div>
                            <div class="layui-card-body">
                                   <div>微信扫码阅读</div>
                                    <div id="qrcode" style="width:100px"></div>
                                    <!--目录div-->
                                <br>
                                <div>目录</div>
                                <div class="js-toc"></div>
                                <a href="#comment">评论区</a>
                            </div>
                    </div>
                </div>
    </div>
</div>

    <span  class="js-toc" style="display: none" id="catalog"></span>

</body>
</html>
<script src="/static/layui/layui.js"></script>
<script src="/static/he-js/content.js"></script>
<script src="/static/js/jquery-1.8.3.js"></script>
<script src="/static/lib/qrcode/qrcode.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    $(function () {

        //生成二维码
        var qrcode = new QRCode("qrcode", {
            text: location.href,
            width:100,
            height:100,
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.H
        });

        tocbot.init ({
            //在哪里渲染目录。
            tocSelector:".js-toc",
            //在哪里抓取标题来构建目录。
            contentSelector:".js-toc-content",
            //在contentSelector元素中抓取哪些标题。
            headingSelector: 'h1, h2, h3',
            //用于内容中相对或绝对定位容器中的标题。
            hasInnerContainers:true,
        });

    })

</script>
"
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:366) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted

2020-04-29 13:25:19.352 ERROR 8956 --- [http-nio-80-exec-9] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]" - line 28, col 45)] with root cause

org.attoparser.ParseException: (Line = 28, Column = 45) Incomplete structure: "<li th:if="  th:if="${session.user!=null}">
                                                <div id="test4"></div>
                                            </li>
                                        </ul>
                                    </div>
                                    <div style="float: right;">
                                        <img style="width:90px" src="/static/img/wx.png">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="layui-col-md3 margin-top" style="position:fixed;top: 10%;right: 5%;">
                    <div class="layui-card">
                        <div class="layui-card-header">百科</div>
                        <div class="layui-card-body">
                           <input type="text" id="baidu" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content"></div>
                        </div>
                </div>
                    <div class="layui-card">
                        <div class="layui-card-header">翻译</div>
                        <div class="layui-card-body">
                            <input type="text" id="translate" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content1"></div>
                        </div>
                    </div>
                    <div class="layui-card">
                        <div class="layui-card-header">阅读工具</div>
                            <div class="layui-card-body">
                                   <div>微信扫码阅读</div>
                                    <div id="qrcode" style="width:100px"></div>
                                    <!--目录div-->
                                <br>
                                <div>目录</div>
                                <div class="js-toc"></div>
                                <a href="#comment">评论区</a>
                            </div>
                    </div>
                </div>
    </div>
</div>

    <span  class="js-toc" style="display: none" id="catalog"></span>

</body>
</html>
<script src="/static/layui/layui.js"></script>
<script src="/static/he-js/content.js"></script>
<script src="/static/js/jquery-1.8.3.js"></script>
<script src="/static/lib/qrcode/qrcode.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    $(function () {

        //生成二维码
        var qrcode = new QRCode("qrcode", {
            text: location.href,
            width:100,
            height:100,
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.H
        });

        tocbot.init ({
            //在哪里渲染目录。
            tocSelector:".js-toc",
            //在哪里抓取标题来构建目录。
            contentSelector:".js-toc-content",
            //在contentSelector元素中抓取哪些标题。
            headingSelector: 'h1, h2, h3',
            //用于内容中相对或绝对定位容器中的标题。
            hasInnerContainers:true,
        });

    })

</script>
"
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:366) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 13:25:20.683  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:25:20.683开始执行getContent
2020-04-29 13:25:20.716  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:25:20.716执行完成getContent
2020-04-29 13:25:20.716  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:25:20.718 ERROR 8956 --- [http-nio-80-exec-8] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-8] Exception processing template "content": An error happened during template parsing (template: "class path resource [templates/content.html]" - line 28, col 45)

org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]" - line 28, col 45)
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:239) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.attoparser.ParseException: (Line = 28, Column = 45) Incomplete structure: "<li th:if="  th:if="${session.user!=null}">
                                                <div id="test4"></div>
                                            </li>
                                        </ul>
                                    </div>
                                    <div style="float: right;">
                                        <img style="width:90px" src="/static/img/wx.png">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="layui-col-md3 margin-top" style="position:fixed;top: 10%;right: 5%;">
                    <div class="layui-card">
                        <div class="layui-card-header">百科</div>
                        <div class="layui-card-body">
                           <input type="text" id="baidu" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content"></div>
                        </div>
                </div>
                    <div class="layui-card">
                        <div class="layui-card-header">翻译</div>
                        <div class="layui-card-body">
                            <input type="text" id="translate" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content1"></div>
                        </div>
                    </div>
                    <div class="layui-card">
                        <div class="layui-card-header">阅读工具</div>
                            <div class="layui-card-body">
                                   <div>微信扫码阅读</div>
                                    <div id="qrcode" style="width:100px"></div>
                                    <!--目录div-->
                                <br>
                                <div>目录</div>
                                <div class="js-toc"></div>
                                <a href="#comment">评论区</a>
                            </div>
                    </div>
                </div>
    </div>
</div>

    <span  class="js-toc" style="display: none" id="catalog"></span>

</body>
</html>
<script src="/static/layui/layui.js"></script>
<script src="/static/he-js/content.js"></script>
<script src="/static/js/jquery-1.8.3.js"></script>
<script src="/static/lib/qrcode/qrcode.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    $(function () {

        //生成二维码
        var qrcode = new QRCode("qrcode", {
            text: location.href,
            width:100,
            height:100,
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.H
        });

        tocbot.init ({
            //在哪里渲染目录。
            tocSelector:".js-toc",
            //在哪里抓取标题来构建目录。
            contentSelector:".js-toc-content",
            //在contentSelector元素中抓取哪些标题。
            headingSelector: 'h1, h2, h3',
            //用于内容中相对或绝对定位容器中的标题。
            hasInnerContainers:true,
        });

    })

</script>
"
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:366) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	... 51 common frames omitted

2020-04-29 13:25:20.719 ERROR 8956 --- [http-nio-80-exec-8] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: An error happened during template parsing (template: "class path resource [templates/content.html]" - line 28, col 45)] with root cause

org.attoparser.ParseException: (Line = 28, Column = 45) Incomplete structure: "<li th:if="  th:if="${session.user!=null}">
                                                <div id="test4"></div>
                                            </li>
                                        </ul>
                                    </div>
                                    <div style="float: right;">
                                        <img style="width:90px" src="/static/img/wx.png">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="layui-col-md3 margin-top" style="position:fixed;top: 10%;right: 5%;">
                    <div class="layui-card">
                        <div class="layui-card-header">百科</div>
                        <div class="layui-card-body">
                           <input type="text" id="baidu" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content"></div>
                        </div>
                </div>
                    <div class="layui-card">
                        <div class="layui-card-header">翻译</div>
                        <div class="layui-card-body">
                            <input type="text" id="translate" required  lay-verify="required" placeholder="请输入标题" autocomplete="off" class="layui-input">
                            <div id="content1"></div>
                        </div>
                    </div>
                    <div class="layui-card">
                        <div class="layui-card-header">阅读工具</div>
                            <div class="layui-card-body">
                                   <div>微信扫码阅读</div>
                                    <div id="qrcode" style="width:100px"></div>
                                    <!--目录div-->
                                <br>
                                <div>目录</div>
                                <div class="js-toc"></div>
                                <a href="#comment">评论区</a>
                            </div>
                    </div>
                </div>
    </div>
</div>

    <span  class="js-toc" style="display: none" id="catalog"></span>

</body>
</html>
<script src="/static/layui/layui.js"></script>
<script src="/static/he-js/content.js"></script>
<script src="/static/js/jquery-1.8.3.js"></script>
<script src="/static/lib/qrcode/qrcode.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
<script>
    $(function () {

        //生成二维码
        var qrcode = new QRCode("qrcode", {
            text: location.href,
            width:100,
            height:100,
            colorDark : "#000000",
            colorLight : "#ffffff",
            correctLevel : QRCode.CorrectLevel.H
        });

        tocbot.init ({
            //在哪里渲染目录。
            tocSelector:".js-toc",
            //在哪里抓取标题来构建目录。
            contentSelector:".js-toc-content",
            //在contentSelector元素中抓取哪些标题。
            headingSelector: 'h1, h2, h3',
            //用于内容中相对或绝对定位容器中的标题。
            hasInnerContainers:true,
        });

    })

</script>
"
	at org.attoparser.MarkupParser.parseDocument(MarkupParser.java:366) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.attoparser.MarkupParser.parse(MarkupParser.java:257) ~[attoparser-2.0.5.RELEASE.jar:2.0.5.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parse(AbstractMarkupTemplateParser.java:230) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.templateparser.markup.AbstractMarkupTemplateParser.parseStandalone(AbstractMarkupTemplateParser.java:100) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:666) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 13:25:30.679  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:25:30.679开始执行getContent
2020-04-29 13:25:30.713  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:25:30.713执行完成getContent
2020-04-29 13:25:30.713  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:25:50.466  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:25:50.466开始执行getContent
2020-04-29 13:25:50.499  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:25:50.499执行完成getContent
2020-04-29 13:25:50.499  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:28:01.606  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:28:01.606开始执行getContent
2020-04-29 13:28:01.674  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:28:01.674执行完成getContent
2020-04-29 13:28:01.674  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:28:52.343  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:28:52.343开始执行count
2020-04-29 13:28:52.376  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:28:52.376执行完成count
2020-04-29 13:28:52.376  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:28:52.381  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:28:52.381开始执行index
2020-04-29 13:28:52.445  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:28:52.445执行完成index
2020-04-29 13:28:52.445  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:32:12.389  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:32:12.389开始执行count
2020-04-29 13:32:12.456  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:32:12.456执行完成count
2020-04-29 13:32:12.456  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:32:12.461  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:32:12.461开始执行index
2020-04-29 13:32:12.526  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:32:12.526执行完成index
2020-04-29 13:32:12.526  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:32:52.733  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:32:52.733开始执行count
2020-04-29 13:32:52.767  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:32:52.767执行完成count
2020-04-29 13:32:52.767  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:32:52.770  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:32:52.770开始执行index
2020-04-29 13:32:52.835  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:32:52.835执行完成index
2020-04-29 13:32:52.835  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:32:55.452  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:32:55.452开始执行count
2020-04-29 13:32:55.485  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:32:55.485执行完成count
2020-04-29 13:32:55.486  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:32:55.492  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:32:55.492开始执行index
2020-04-29 13:32:55.557  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:32:55.557执行完成index
2020-04-29 13:32:55.557  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:33:23.123  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:33:23.123开始执行count
2020-04-29 13:33:23.155  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:33:23.155执行完成count
2020-04-29 13:33:23.155  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:33:23.178  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:33:23.178开始执行index
2020-04-29 13:33:23.244  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:33:23.244执行完成index
2020-04-29 13:33:23.244  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:33:42.168  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:33:42.168开始执行count
2020-04-29 13:33:42.201  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:33:42.201执行完成count
2020-04-29 13:33:42.201  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:33:42.205  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:33:42.205开始执行index
2020-04-29 13:33:42.273  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:33:42.273执行完成index
2020-04-29 13:33:42.273  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:34:39.177  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:34:39.177开始执行count
2020-04-29 13:34:39.209  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:34:39.209执行完成count
2020-04-29 13:34:39.210  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:34:39.214  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:34:39.214开始执行index
2020-04-29 13:34:39.285  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:34:39.285执行完成index
2020-04-29 13:34:39.285  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:34:49.295  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:34:49.295开始执行count
2020-04-29 13:34:49.329  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:34:49.329执行完成count
2020-04-29 13:34:49.329  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:34:49.333  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:34:49.333开始执行index
2020-04-29 13:34:49.396  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:34:49.396执行完成index
2020-04-29 13:34:49.396  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:34:57.751  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:34:57.751开始执行count
2020-04-29 13:34:57.784  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:34:57.784执行完成count
2020-04-29 13:34:57.785  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:34:57.791  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:34:57.791开始执行index
2020-04-29 13:34:57.856  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:34:57.856执行完成index
2020-04-29 13:34:57.856  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:35:12.975  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:35:12.975开始执行count
2020-04-29 13:35:13.009  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:35:13.009执行完成count
2020-04-29 13:35:13.009  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:35:13.014  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:35:13.014开始执行index
2020-04-29 13:35:13.078  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:35:13.078执行完成index
2020-04-29 13:35:13.078  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:35:52.929  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:35:52.929开始执行count
2020-04-29 13:35:52.962  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:35:52.962执行完成count
2020-04-29 13:35:52.962  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:35:52.967  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:35:52.967开始执行index
2020-04-29 13:35:53.031  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:35:53.031执行完成index
2020-04-29 13:35:53.031  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:36:03.751  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:36:03.751开始执行count
2020-04-29 13:36:03.785  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:36:03.785执行完成count
2020-04-29 13:36:03.785  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:36:03.793  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:36:03.793开始执行index
2020-04-29 13:36:03.862  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:36:03.862执行完成index
2020-04-29 13:36:03.862  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:36:18.188  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:36:18.188开始执行count
2020-04-29 13:36:18.223  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:36:18.223执行完成count
2020-04-29 13:36:18.223  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:36:18.228  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:36:18.228开始执行index
2020-04-29 13:36:18.293  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:36:18.293执行完成index
2020-04-29 13:36:18.293  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:36:28.442  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:36:28.442开始执行count
2020-04-29 13:36:28.476  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:36:28.476执行完成count
2020-04-29 13:36:28.476  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:36:28.481  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:36:28.481开始执行index
2020-04-29 13:36:28.545  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:36:28.545执行完成index
2020-04-29 13:36:28.545  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:37:39.809  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:37:39.809开始执行getContent
2020-04-29 13:37:39.875  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:37:39.875执行完成getContent
2020-04-29 13:37:39.875  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:37:39.888  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:37:39.892  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:37:39.893  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:37:39.894  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:37:58.344  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:37:58.344开始执行getContent
2020-04-29 13:37:58.378  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:37:58.378执行完成getContent
2020-04-29 13:37:58.378  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:37:58.396  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:37:58.406  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:37:58.407  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:37:58.408  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:37:59.056  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:37:59.056开始执行getContent
2020-04-29 13:37:59.090  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:37:59.090执行完成getContent
2020-04-29 13:37:59.090  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:37:59.105  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:37:59.110  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:37:59.110  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:37:59.112  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:38:38.755  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:38:38.755开始执行getContent
2020-04-29 13:38:38.788  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:38:38.788执行完成getContent
2020-04-29 13:38:38.788  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:38:38.803  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:38:38.806  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:38:38.808  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:38:38.808  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:38:59.015  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:38:59.015开始执行getContent
2020-04-29 13:38:59.048  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:38:59.048执行完成getContent
2020-04-29 13:38:59.048  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:38:59.062  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:38:59.066  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:38:59.066  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:38:59.068  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:42:01.550  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:42:01.550开始执行getContent
2020-04-29 13:42:01.619  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:42:01.619执行完成getContent
2020-04-29 13:42:01.619  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:42:01.643  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:42:01.647  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:42:01.652  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:42:01.653  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:42:20.612  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:42:20.612开始执行getContent
2020-04-29 13:42:20.645  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:42:20.645执行完成getContent
2020-04-29 13:42:20.646  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:42:20.681  WARN 8956 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:42:20.682  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:42:20.683  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:42:20.685  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:42:21.454  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:42:21.454开始执行getContent
2020-04-29 13:42:21.487  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:42:21.487执行完成getContent
2020-04-29 13:42:21.487  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:42:21.507  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:42:21.508  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:42:21.510  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:42:21.510  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:42:21.825  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:42:21.825开始执行getContent
2020-04-29 13:42:21.859  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:42:21.859执行完成getContent
2020-04-29 13:42:21.859  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:42:21.878  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:42:21.878  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:42:21.879  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:42:21.882  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:42:27.396  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:42:27.396开始执行getContent
2020-04-29 13:42:27.431  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:42:27.431执行完成getContent
2020-04-29 13:42:27.431  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:42:27.450  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:42:27.451  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:42:27.453  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:42:27.457  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:42:48.182  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:42:48.182开始执行getContent
2020-04-29 13:42:48.216  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:42:48.216执行完成getContent
2020-04-29 13:42:48.216  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:42:48.238  WARN 8956 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:42:48.238  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:42:48.238  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:42:48.238  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:25.764  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:43:25.764开始执行getContent
2020-04-29 13:43:25.799  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:43:25.799执行完成getContent
2020-04-29 13:43:25.799  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:25.828  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:25.828  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:25.829  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:25.835  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:43:26.392  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:43:26.392开始执行getContent
2020-04-29 13:43:26.430  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:43:26.430执行完成getContent
2020-04-29 13:43:26.430  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:26.459  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:26.461  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:26.466  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:43:26.466  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:26.689  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:43:26.689开始执行getContent
2020-04-29 13:43:26.724  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:43:26.724执行完成getContent
2020-04-29 13:43:26.725  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:26.745  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:26.746  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:26.746  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:26.750  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:43:26.919  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:43:26.919开始执行getContent
2020-04-29 13:43:26.953  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:43:26.953执行完成getContent
2020-04-29 13:43:26.953  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:26.978  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:26.984  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:26.984  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:26.985  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:43:27.371  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:43:27.371开始执行getContent
2020-04-29 13:43:27.407  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:43:27.407执行完成getContent
2020-04-29 13:43:27.407  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:27.430  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:27.430  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:27.430  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:27.431  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:43:29.266  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:43:29.266开始执行getContent
2020-04-29 13:43:29.299  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:43:29.299执行完成getContent
2020-04-29 13:43:29.299  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:29.321  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:29.321  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:29.322  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:29.322  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:43:40.181  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:43:40.181开始执行getContent
2020-04-29 13:43:40.214  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:43:40.214执行完成getContent
2020-04-29 13:43:40.214  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:40.236  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:40.237  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:40.237  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:40.237  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:43:49.330  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:43:49.330开始执行getContent
2020-04-29 13:43:49.364  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:43:49.364执行完成getContent
2020-04-29 13:43:49.364  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:43:49.385  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:43:49.389  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:43:49.389  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:43:49.390  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:01.006  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:45:01.006开始执行getContent
2020-04-29 13:45:01.072  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:45:01.072执行完成getContent
2020-04-29 13:45:01.072  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:01.091  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:01.098  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:01.098  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:01.098  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:01.676  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:45:01.676开始执行getContent
2020-04-29 13:45:01.710  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:45:01.710执行完成getContent
2020-04-29 13:45:01.710  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:01.729  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:01.732  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:01.733  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:01.733  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:01.907  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:45:01.907开始执行getContent
2020-04-29 13:45:01.941  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:45:01.941执行完成getContent
2020-04-29 13:45:01.941  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:01.965  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:01.970  WARN 8956 --- [http-nio-80-exec-4] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:01.971  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:01.972  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:12.787  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:45:12.787开始执行getContent
2020-04-29 13:45:12.822  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:45:12.822执行完成getContent
2020-04-29 13:45:12.822  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:12.838  WARN 8956 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:12.845  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:12.846  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:12.846  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:13.643  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:45:13.643开始执行getContent
2020-04-29 13:45:13.676  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:45:13.676执行完成getContent
2020-04-29 13:45:13.676  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:13.691  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:13.695  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:13.696  WARN 8956 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:13.696  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:13.883  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:45:13.883开始执行getContent
2020-04-29 13:45:13.917  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:45:13.917执行完成getContent
2020-04-29 13:45:13.918  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:13.938  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:13.945  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:13.947  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:13.948  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:14.329  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:45:14.329开始执行getContent
2020-04-29 13:45:14.363  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:45:14.363执行完成getContent
2020-04-29 13:45:14.364  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:14.376  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:14.382  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:14.382  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:14.383  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:24.691  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:45:24.691开始执行getContent
2020-04-29 13:45:24.724  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:45:24.724执行完成getContent
2020-04-29 13:45:24.724  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:24.757  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:24.764  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:24.766  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:24.769  WARN 8956 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:25.399  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:45:25.399开始执行getContent
2020-04-29 13:45:25.433  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:45:25.433执行完成getContent
2020-04-29 13:45:25.433  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:25.445  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:25.454  WARN 8956 --- [http-nio-80-exec-7] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:25.455  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:25.456  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:25.845  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:45:25.845开始执行getContent
2020-04-29 13:45:25.878  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:45:25.878执行完成getContent
2020-04-29 13:45:25.878  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:25.891  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:25.898  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:25.898  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:25.899  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:54.600  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:45:54.600开始执行getContent
2020-04-29 13:45:54.641  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:45:54.641执行完成getContent
2020-04-29 13:45:54.641  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:54.655  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:54.662  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:54.662  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:54.663  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:55.188  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:45:55.187开始执行getContent
2020-04-29 13:45:55.221  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:45:55.221执行完成getContent
2020-04-29 13:45:55.221  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:55.237  WARN 8956 --- [http-nio-80-exec-5] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:55.243  WARN 8956 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:55.243  WARN 8956 --- [http-nio-80-exec-3] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:55.243  WARN 8956 --- [http-nio-80-exec-2] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:45:55.612  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:45:55.612开始执行getContent
2020-04-29 13:45:55.646  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:45:55.646执行完成getContent
2020-04-29 13:45:55.646  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:45:55.661  WARN 8956 --- [http-nio-80-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/matt.jpg
2020-04-29 13:45:55.682  WARN 8956 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/elliot.jpg
2020-04-29 13:45:55.682  WARN 8956 --- [http-nio-80-exec-8] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/jenny.jpg
2020-04-29 13:45:55.682  WARN 8956 --- [http-nio-80-exec-9] o.s.web.servlet.PageNotFound             : No mapping for GET /images/avatar/small/joe.jpg
2020-04-29 13:46:24.374  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:46:24.374开始执行getContent
2020-04-29 13:46:24.412  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:46:24.412执行完成getContent
2020-04-29 13:46:24.412  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:46:25.302  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:46:25.302开始执行getContent
2020-04-29 13:46:25.335  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:46:25.335执行完成getContent
2020-04-29 13:46:25.335  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:46:40.874  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:46:40.874开始执行getContent
2020-04-29 13:46:40.909  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:46:40.909执行完成getContent
2020-04-29 13:46:40.910  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:46:56.819  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:46:56.819开始执行getContent
2020-04-29 13:46:56.853  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:46:56.853执行完成getContent
2020-04-29 13:46:56.853  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:47:13.567  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:47:13.567开始执行getContent
2020-04-29 13:47:13.600  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:47:13.600执行完成getContent
2020-04-29 13:47:13.600  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:47:29.961  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:47:29.960开始执行getContent
2020-04-29 13:47:29.992  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:47:29.992执行完成getContent
2020-04-29 13:47:29.992  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:48:44.560  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:48:44.560开始执行getContent
2020-04-29 13:48:44.625  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:48:44.625执行完成getContent
2020-04-29 13:48:44.626  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 13:53:40.123  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:53:40.123开始执行count
2020-04-29 13:53:42.172  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:53:42.172执行完成count
2020-04-29 13:53:42.172  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:53:43.367  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:53:43.367开始执行count
2020-04-29 13:53:43.403  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T13:53:43.403执行完成count
2020-04-29 13:53:43.403  INFO 8956 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:53:43.407  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:53:43.407开始执行index
2020-04-29 13:53:43.480  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:53:43.480执行完成index
2020-04-29 13:53:43.481  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:53:46.143  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:53:46.143开始执行index
2020-04-29 13:53:46.213  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:53:46.213执行完成index
2020-04-29 13:53:46.213  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:53:49.088  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:53:49.088开始执行index
2020-04-29 13:53:49.158  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:53:49.158执行完成index
2020-04-29 13:53:49.158  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:53:50.697  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:53:50.697开始执行count
2020-04-29 13:53:50.734  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:53:50.734执行完成count
2020-04-29 13:53:50.734  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:53:50.739  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:53:50.739开始执行index
2020-04-29 13:53:50.823  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:53:50.823执行完成index
2020-04-29 13:53:50.823  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:53:50.943  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:53:50.943开始执行count
2020-04-29 13:53:50.979  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T13:53:50.979执行完成count
2020-04-29 13:53:50.979  INFO 8956 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:53:50.985  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:53:50.985开始执行index
2020-04-29 13:53:51.056  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:53:51.056执行完成index
2020-04-29 13:53:51.056  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:53:51.996  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:53:51.996开始执行count
2020-04-29 13:53:52.032  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T13:53:52.032执行完成count
2020-04-29 13:53:52.032  INFO 8956 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:53:52.035  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:53:52.035开始执行index
2020-04-29 13:53:52.109  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:53:52.109执行完成index
2020-04-29 13:53:52.109  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:53:52.941  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:53:52.941开始执行count
2020-04-29 13:53:52.977  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:53:52.977执行完成count
2020-04-29 13:53:52.977  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:53:52.982  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:53:52.982开始执行index
2020-04-29 13:53:53.050  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T13:53:53.050执行完成index
2020-04-29 13:53:53.050  INFO 8956 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:53:58.424  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:53:58.424开始执行index
2020-04-29 13:53:58.494  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:53:58.494执行完成index
2020-04-29 13:53:58.494  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:54:01.582  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:54:01.582开始执行index
2020-04-29 13:54:01.652  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T13:54:01.652执行完成index
2020-04-29 13:54:01.653  INFO 8956 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:55:46.353  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:55:46.353开始执行count
2020-04-29 13:55:46.424  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T13:55:46.424执行完成count
2020-04-29 13:55:46.424  INFO 8956 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:55:46.429  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:55:46.429开始执行index
2020-04-29 13:55:46.499  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:55:46.499执行完成index
2020-04-29 13:55:46.499  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:55:54.027  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:55:54.027开始执行count
2020-04-29 13:55:54.063  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T13:55:54.063执行完成count
2020-04-29 13:55:54.063  INFO 8956 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:55:54.066  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:55:54.066开始执行index
2020-04-29 13:55:54.136  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T13:55:54.136执行完成index
2020-04-29 13:55:54.137  INFO 8956 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 13:56:32.933  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:56:32.933开始执行count
2020-04-29 13:56:32.969  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T13:56:32.969执行完成count
2020-04-29 13:56:32.969  INFO 8956 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 13:56:32.973  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:56:32.973开始执行index
2020-04-29 13:56:33.049  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T13:56:33.049执行完成index
2020-04-29 13:56:33.049  INFO 8956 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。:来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=7, original=1, commentable=1, createTime=Tue Apr 28 23:50:55 CST 2020, updateTime=Tue Apr 28 23:50:55 CST 2020, flag=1, appreciate=1, typeId=14, title=第一篇博客, outline=博客大纲, avatar=http://q9hljz6bo.bkt.clouddn.com/41533aa2351244b9b3c66b3659b5d793, content=开始动笔把), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:38:58.307  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 18:38:58.309  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 18:39:04.678  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 18:39:05.047  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 7.376 seconds (JVM running for 8.597)
2020-04-29 18:39:07.952  WARN 20696 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /favicon.ico
2020-04-29 18:39:07.977  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:39:07.976开始执行count
2020-04-29 18:39:08.100  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:39:08.100执行完成count
2020-04-29 18:39:08.101  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:39:08.112  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:39:08.112开始执行index
2020-04-29 18:39:08.209  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:39:08.209执行完成index
2020-04-29 18:39:08.209  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:39:14.204  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:39:14.204开始执行index
2020-04-29 18:39:14.268  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:39:14.268执行完成index
2020-04-29 18:39:14.269  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:39:15.436  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:39:15.436开始执行index
2020-04-29 18:39:15.502  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:39:15.502执行完成index
2020-04-29 18:39:15.502  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:39:20.352  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:39:20.352开始执行count
2020-04-29 18:39:20.384  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:39:20.384执行完成count
2020-04-29 18:39:20.384  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:39:20.388  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:39:20.388开始执行index
2020-04-29 18:39:20.454  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:39:20.454执行完成index
2020-04-29 18:39:20.454  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:41:24.100  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:41:24.100开始执行count
2020-04-29 18:41:24.171  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:41:24.171执行完成count
2020-04-29 18:41:24.171  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:41:24.177  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:41:24.177开始执行index
2020-04-29 18:41:24.244  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:41:24.244执行完成index
2020-04-29 18:41:24.244  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:41:39.667  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:41:39.667开始执行count
2020-04-29 18:41:39.700  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:41:39.700执行完成count
2020-04-29 18:41:39.700  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:41:39.705  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:41:39.705开始执行index
2020-04-29 18:41:39.770  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:41:39.770执行完成index
2020-04-29 18:41:39.770  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:41:40.692  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:41:40.692开始执行count
2020-04-29 18:41:40.724  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:41:40.724执行完成count
2020-04-29 18:41:40.724  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:41:40.728  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:41:40.728开始执行index
2020-04-29 18:41:40.792  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:41:40.792执行完成index
2020-04-29 18:41:40.792  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:42:05.638  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:42:05.638开始执行count
2020-04-29 18:42:05.672  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:42:05.672执行完成count
2020-04-29 18:42:05.672  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:42:05.677  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:42:05.677开始执行index
2020-04-29 18:42:05.742  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:42:05.742执行完成index
2020-04-29 18:42:05.742  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:01.815  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:43:01.815开始执行count
2020-04-29 18:43:01.848  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:43:01.848执行完成count
2020-04-29 18:43:01.848  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:01.854  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:43:01.854开始执行index
2020-04-29 18:43:01.919  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:43:01.919执行完成index
2020-04-29 18:43:01.920  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:02.444  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.444开始执行count
2020-04-29 18:43:02.477  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.477执行完成count
2020-04-29 18:43:02.477  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:02.541  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.541开始执行index
2020-04-29 18:43:02.606  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.606执行完成index
2020-04-29 18:43:02.606  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:02.836  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.836开始执行count
2020-04-29 18:43:02.869  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.869执行完成count
2020-04-29 18:43:02.869  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:02.876  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.876开始执行index
2020-04-29 18:43:02.940  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:43:02.940执行完成index
2020-04-29 18:43:02.940  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:03.050  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.050开始执行count
2020-04-29 18:43:03.083  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.083执行完成count
2020-04-29 18:43:03.083  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:03.087  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.087开始执行index
2020-04-29 18:43:03.151  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.151执行完成index
2020-04-29 18:43:03.151  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:03.317  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.317开始执行count
2020-04-29 18:43:03.350  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.350执行完成count
2020-04-29 18:43:03.350  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:03.354  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.354开始执行index
2020-04-29 18:43:03.418  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.418执行完成index
2020-04-29 18:43:03.419  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:03.496  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.496开始执行count
2020-04-29 18:43:03.528  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.528执行完成count
2020-04-29 18:43:03.528  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:03.532  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.532开始执行index
2020-04-29 18:43:03.594  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.594执行完成index
2020-04-29 18:43:03.594  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:03.801  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.801开始执行count
2020-04-29 18:43:03.833  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.833执行完成count
2020-04-29 18:43:03.833  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:03.838  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.838开始执行index
2020-04-29 18:43:03.904  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:43:03.904执行完成index
2020-04-29 18:43:03.904  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:18.429  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:43:18.429开始执行count
2020-04-29 18:43:18.461  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:43:18.461执行完成count
2020-04-29 18:43:18.461  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:18.467  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:43:18.467开始执行index
2020-04-29 18:43:18.531  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:43:18.531执行完成index
2020-04-29 18:43:18.531  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:37.239  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:43:37.239开始执行count
2020-04-29 18:43:37.283  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:43:37.283执行完成count
2020-04-29 18:43:37.283  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:37.286  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:43:37.286开始执行index
2020-04-29 18:43:37.365  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:43:37.365执行完成index
2020-04-29 18:43:37.365  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:43:50.150  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:43:50.150开始执行count
2020-04-29 18:43:50.186  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:43:50.186执行完成count
2020-04-29 18:43:50.186  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:43:50.194  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:43:50.194开始执行index
2020-04-29 18:43:50.258  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:43:50.258执行完成index
2020-04-29 18:43:50.258  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:44:15.500  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:44:15.500开始执行count
2020-04-29 18:44:15.538  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:44:15.538执行完成count
2020-04-29 18:44:15.538  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:44:15.542  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:44:15.542开始执行index
2020-04-29 18:44:15.606  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:44:15.606执行完成index
2020-04-29 18:44:15.606  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:44:16.320  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:44:16.320开始执行count
2020-04-29 18:44:16.354  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:44:16.354执行完成count
2020-04-29 18:44:16.354  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:44:16.358  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:44:16.358开始执行index
2020-04-29 18:44:16.427  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:44:16.427执行完成index
2020-04-29 18:44:16.427  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:44:30.663  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:44:30.663开始执行count
2020-04-29 18:44:30.729  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:44:30.729执行完成count
2020-04-29 18:44:30.729  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:44:30.733  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:44:30.733开始执行index
2020-04-29 18:44:30.836  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:44:30.836执行完成index
2020-04-29 18:44:30.836  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:44:45.904  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:44:45.904开始执行count
2020-04-29 18:44:45.937  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:44:45.937执行完成count
2020-04-29 18:44:45.937  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:44:45.941  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:44:45.941开始执行index
2020-04-29 18:44:46.003  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:44:46.003执行完成index
2020-04-29 18:44:46.004  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:03.172  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:45:03.172开始执行count
2020-04-29 18:45:03.203  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:45:03.203执行完成count
2020-04-29 18:45:03.204  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:03.208  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:45:03.208开始执行index
2020-04-29 18:45:03.271  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:45:03.271执行完成index
2020-04-29 18:45:03.271  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:04.143  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:45:04.143开始执行count
2020-04-29 18:45:04.177  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:45:04.177执行完成count
2020-04-29 18:45:04.177  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:04.181  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:45:04.181开始执行index
2020-04-29 18:45:04.242  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:45:04.242执行完成index
2020-04-29 18:45:04.242  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:30.886  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:45:30.886开始执行count
2020-04-29 18:45:30.917  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:45:30.917执行完成count
2020-04-29 18:45:30.918  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:30.921  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:45:30.921开始执行index
2020-04-29 18:45:30.984  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:45:30.984执行完成index
2020-04-29 18:45:30.984  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:33.775  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:45:33.775开始执行count
2020-04-29 18:45:33.806  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:45:33.806执行完成count
2020-04-29 18:45:33.806  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:33.810  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:45:33.810开始执行index
2020-04-29 18:45:33.871  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:45:33.871执行完成index
2020-04-29 18:45:33.871  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:40.451  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:45:40.451开始执行login
2020-04-29 18:45:40.509  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:45:40.509执行完成login
2020-04-29 18:45:40.509  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=登陆成功, code=null, count=null, data=User(id=1, usename=何正, email=2218359849@qq.com, pass=666666, avatar=/static/img/index.jpg, age=25, address=湖北省孝感市, job=java开发, level=null, userType=0, createTime=Tue Apr 28 20:30:02 CST 2020, updateTime=Tue Apr 28 20:30:02 CST 2020, online=0, flag=1, logined=0))
2020-04-29 18:45:41.623  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:45:41.623开始执行count
2020-04-29 18:45:41.654  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:45:41.654执行完成count
2020-04-29 18:45:41.654  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:41.679  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:45:41.679开始执行index
2020-04-29 18:45:41.740  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:45:41.740执行完成index
2020-04-29 18:45:41.740  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:42.452  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:45:42.452开始执行count
2020-04-29 18:45:42.490  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:45:42.490执行完成count
2020-04-29 18:45:42.490  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:42.494  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:45:42.494开始执行index
2020-04-29 18:45:42.556  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:45:42.555执行完成index
2020-04-29 18:45:42.556  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:47.471  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:45:47.471开始执行count
2020-04-29 18:45:47.503  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:45:47.503执行完成count
2020-04-29 18:45:47.504  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:47.515  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:45:47.515开始执行index
2020-04-29 18:45:47.578  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:45:47.578执行完成index
2020-04-29 18:45:47.578  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:45:57.110  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:45:57.110开始执行count
2020-04-29 18:45:57.142  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:45:57.142执行完成count
2020-04-29 18:45:57.143  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:45:57.147  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:45:57.147开始执行index
2020-04-29 18:45:57.209  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:45:57.209执行完成index
2020-04-29 18:45:57.209  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:46:14.164  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:46:14.164开始执行count
2020-04-29 18:46:14.198  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:46:14.198执行完成count
2020-04-29 18:46:14.198  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:46:14.202  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:46:14.202开始执行index
2020-04-29 18:46:14.265  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:46:14.265执行完成index
2020-04-29 18:46:14.265  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:47:07.684  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:47:07.684开始执行count
2020-04-29 18:47:07.716  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:47:07.716执行完成count
2020-04-29 18:47:07.716  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:47:07.721  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:47:07.721开始执行index
2020-04-29 18:47:07.783  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:47:07.783执行完成index
2020-04-29 18:47:07.784  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:47:47.469  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:47:47.469开始执行count
2020-04-29 18:47:47.506  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:47:47.506执行完成count
2020-04-29 18:47:47.507  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:47:47.581  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:47:47.581开始执行index
2020-04-29 18:47:47.647  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:47:47.647执行完成index
2020-04-29 18:47:47.647  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:48:21.492  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:48:21.492开始执行count
2020-04-29 18:48:21.524  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:48:21.524执行完成count
2020-04-29 18:48:21.524  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:48:21.528  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:48:21.528开始执行index
2020-04-29 18:48:21.590  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:48:21.590执行完成index
2020-04-29 18:48:21.591  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:53:05.176  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 18:53:05.176  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 18:53:07.990  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 18:53:08.179  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 3.029 seconds (JVM running for 851.729)
2020-04-29 18:53:08.352  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:53:08.352开始执行count
2020-04-29 18:53:08.391  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:53:08.391执行完成count
2020-04-29 18:53:08.391  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:53:08.397  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:53:08.397开始执行index
2020-04-29 18:53:08.477  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:53:08.477执行完成index
2020-04-29 18:53:08.478  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:53:15.531  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:53:15.531开始执行count
2020-04-29 18:53:15.565  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:53:15.565执行完成count
2020-04-29 18:53:15.565  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:53:15.569  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:53:15.569开始执行index
2020-04-29 18:53:15.636  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T18:53:15.636执行完成index
2020-04-29 18:53:15.636  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:53:45.843  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 18:53:45.843  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 18:53:48.543  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 18:53:48.720  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 2.93 seconds (JVM running for 892.27)
2020-04-29 18:53:51.599  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 18:53:51.599  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 18:53:54.381  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 18:53:54.573  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 2.994 seconds (JVM running for 898.12)
2020-04-29 18:53:55.549  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:53:55.549开始执行count
2020-04-29 18:53:55.592  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:53:55.592执行完成count
2020-04-29 18:53:55.593  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:53:55.648  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:53:55.648开始执行index
2020-04-29 18:53:55.733  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:53:55.733执行完成index
2020-04-29 18:53:55.734  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:53:57.727  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:53:57.727开始执行index
2020-04-29 18:53:57.803  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T18:53:57.803执行完成index
2020-04-29 18:53:57.803  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:54:14.845  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:54:14.845开始执行count
2020-04-29 18:54:14.885  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T18:54:14.884执行完成count
2020-04-29 18:54:14.885  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:54:14.891  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:54:14.891开始执行index
2020-04-29 18:54:14.968  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:54:14.968执行完成index
2020-04-29 18:54:14.968  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:54:31.691  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:54:31.690开始执行index
2020-04-29 18:54:31.768  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:54:31.768执行完成index
2020-04-29 18:54:31.768  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:54:37.026  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:54:37.026开始执行index
2020-04-29 18:54:37.105  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T18:54:37.105执行完成index
2020-04-29 18:54:37.105  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:54:38.222  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:54:38.222开始执行index
2020-04-29 18:54:38.298  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:54:38.298执行完成index
2020-04-29 18:54:38.298  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:58:05.632  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:58:05.632开始执行count
2020-04-29 18:58:05.710  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:58:05.710执行完成count
2020-04-29 18:58:05.710  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:58:05.714  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:58:05.714开始执行index
2020-04-29 18:58:05.791  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:58:05.791执行完成index
2020-04-29 18:58:05.791  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:58:06.201  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:58:06.201开始执行count
2020-04-29 18:58:06.240  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:58:06.240执行完成count
2020-04-29 18:58:06.240  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:58:06.244  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:58:06.243开始执行index
2020-04-29 18:58:06.321  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T18:58:06.321执行完成index
2020-04-29 18:58:06.321  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:58:07.152  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 18:58:07.152  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 18:58:10.158  WARN 20696 --- [restartedMain] ConfigServletWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'heController': Unsatisfied dependency expressed through field 'blogService'; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.blog.service.BlogService' available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
2020-04-29 18:58:10.230 ERROR 20696 --- [restartedMain] o.s.b.d.LoggingFailureAnalysisReporter   : 

***************************
APPLICATION FAILED TO START
***************************

Description:

Field blogService in com.blog.controller.HeController required a bean of type 'com.blog.service.BlogService' that could not be found.

The injection point has the following annotations:
	- @org.springframework.beans.factory.annotation.Autowired(required=true)


Action:

Consider defining a bean of type 'com.blog.service.BlogService' in your configuration.

2020-04-29 18:58:14.896  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 18:58:14.896  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 18:58:17.790  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 18:58:17.963  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 3.087 seconds (JVM running for 1161.512)
2020-04-29 18:58:19.691  WARN 20696 --- [http-nio-80-exec-10] o.s.web.servlet.PageNotFound             : No mapping for GET /blog/blog/count
2020-04-29 18:59:15.652  WARN 20696 --- [http-nio-80-exec-6] o.s.web.servlet.PageNotFound             : No mapping for GET /blog/blog/count
2020-04-29 18:59:16.219  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 18:59:16.219  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 18:59:18.940  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 18:59:19.149  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 2.956 seconds (JVM running for 1222.699)
2020-04-29 18:59:22.645  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:59:22.645开始执行count
2020-04-29 18:59:22.683  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T18:59:22.683执行完成count
2020-04-29 18:59:22.683  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 18:59:22.697  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:59:22.697开始执行index
2020-04-29 18:59:22.777  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T18:59:22.777执行完成index
2020-04-29 18:59:22.777  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:59:29.751  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:59:29.751开始执行index
2020-04-29 18:59:29.828  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T18:59:29.828执行完成index
2020-04-29 18:59:29.828  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 18:59:38.588  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:59:38.588开始执行index
2020-04-29 18:59:38.657  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T18:59:38.657执行完成index
2020-04-29 18:59:38.657  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[])
2020-04-29 18:59:40.889  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:59:40.889开始执行index
2020-04-29 18:59:40.958  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T18:59:40.958执行完成index
2020-04-29 18:59:40.958  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:00:12.443  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 19:00:12.443  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 19:00:15.687  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 19:00:15.951  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 3.529 seconds (JVM running for 1279.502)
2020-04-29 19:02:17.392 ERROR 20696 --- [http-nio-80-exec-7] c.b.handler.ControllerExceptionHandler   : Request URL : http://localhost/blog/blog/count,EXxception : {}

java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.updateNamedValueInfo(AbstractNamedValueMethodArgumentResolver.java:172) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.getNamedValueInfo(AbstractNamedValueMethodArgumentResolver.java:149) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.annotation.AbstractNamedValueMethodArgumentResolver.resolveArgument(AbstractNamedValueMethodArgumentResolver.java:99) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:167) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:134) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 19:02:17.395  WARN 20696 --- [http-nio-80-exec-7] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [java.lang.IllegalArgumentException: Name for argument type [java.lang.String] not available, and parameter name information not found in class file either.]
2020-04-29 19:02:17.411  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:02:17.410开始执行index
2020-04-29 19:02:17.513  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:02:17.513执行完成index
2020-04-29 19:02:17.513  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:02:18.457  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 19:02:18.457  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 19:02:21.300  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 19:02:21.699  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 3.267 seconds (JVM running for 1405.249)
2020-04-29 19:02:23.613  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:02:23.613开始执行count
2020-04-29 19:02:23.653  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:02:23.653执行完成count
2020-04-29 19:02:23.654  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:02:23.662  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:02:23.662开始执行index
2020-04-29 19:02:23.734  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:02:23.734执行完成index
2020-04-29 19:02:23.734  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:02:31.422  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:02:31.422开始执行index
2020-04-29 19:02:31.502  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:02:31.502执行完成index
2020-04-29 19:02:31.502  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:47.974  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:47.974开始执行count
2020-04-29 19:03:47.974  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:47.974开始执行index
2020-04-29 19:03:48.045  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.045执行完成count
2020-04-29 19:03:48.045  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.049  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.049开始执行count
2020-04-29 19:03:48.072  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.072执行完成index
2020-04-29 19:03:48.072  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.077  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.076开始执行index
2020-04-29 19:03:48.083  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.083执行完成count
2020-04-29 19:03:48.083  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.087  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.087开始执行count
2020-04-29 19:03:48.125  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.125执行完成count
2020-04-29 19:03:48.125  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.129  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.129开始执行count
2020-04-29 19:03:48.148  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.148执行完成index
2020-04-29 19:03:48.148  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.152  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.151开始执行index
2020-04-29 19:03:48.164  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.164执行完成count
2020-04-29 19:03:48.164  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.168  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.168开始执行count
2020-04-29 19:03:48.203  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.203执行完成count
2020-04-29 19:03:48.203  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.206  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.206开始执行count
2020-04-29 19:03:48.218  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.218执行完成index
2020-04-29 19:03:48.219  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.224  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.224开始执行index
2020-04-29 19:03:48.242  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.242执行完成count
2020-04-29 19:03:48.242  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.245  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.244开始执行count
2020-04-29 19:03:48.280  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.280执行完成count
2020-04-29 19:03:48.280  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.283  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.283开始执行count
2020-04-29 19:03:48.287  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.287执行完成index
2020-04-29 19:03:48.287  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.290  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.290开始执行index
2020-04-29 19:03:48.318  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.318执行完成count
2020-04-29 19:03:48.318  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.322  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.321开始执行count
2020-04-29 19:03:48.354  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.354执行完成index
2020-04-29 19:03:48.354  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.359  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.359执行完成count
2020-04-29 19:03:48.359  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.360  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.360开始执行index
2020-04-29 19:03:48.365  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.365开始执行count
2020-04-29 19:03:48.397  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.397执行完成count
2020-04-29 19:03:48.398  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.401  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.401开始执行count
2020-04-29 19:03:48.429  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.429执行完成index
2020-04-29 19:03:48.429  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.433  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.433执行完成count
2020-04-29 19:03:48.433  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.434  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.434开始执行index
2020-04-29 19:03:48.438  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.438开始执行count
2020-04-29 19:03:48.475  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.475执行完成count
2020-04-29 19:03:48.475  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.478  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.478开始执行count
2020-04-29 19:03:48.498  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.498执行完成index
2020-04-29 19:03:48.499  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.502  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.502开始执行index
2020-04-29 19:03:48.515  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.515执行完成count
2020-04-29 19:03:48.515  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.518  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.518开始执行count
2020-04-29 19:03:48.555  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.555执行完成count
2020-04-29 19:03:48.555  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.566  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.566开始执行count
2020-04-29 19:03:48.570  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.570执行完成index
2020-04-29 19:03:48.570  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.576  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.576开始执行index
2020-04-29 19:03:48.611  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.611执行完成count
2020-04-29 19:03:48.611  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.616  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.616开始执行count
2020-04-29 19:03:48.645  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.645执行完成index
2020-04-29 19:03:48.645  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.648  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.648开始执行index
2020-04-29 19:03:48.653  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.653执行完成count
2020-04-29 19:03:48.653  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.657  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.656开始执行count
2020-04-29 19:03:48.691  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.691执行完成count
2020-04-29 19:03:48.691  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.695  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.695开始执行count
2020-04-29 19:03:48.712  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.712执行完成index
2020-04-29 19:03:48.712  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.716  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.716开始执行index
2020-04-29 19:03:48.731  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.731执行完成count
2020-04-29 19:03:48.731  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.734  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.734开始执行count
2020-04-29 19:03:48.770  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.770执行完成count
2020-04-29 19:03:48.770  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.773  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.773开始执行count
2020-04-29 19:03:48.780  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.780执行完成index
2020-04-29 19:03:48.780  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.785  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.785开始执行index
2020-04-29 19:03:48.811  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.811执行完成count
2020-04-29 19:03:48.811  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.814  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.814开始执行count
2020-04-29 19:03:48.849  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.849执行完成count
2020-04-29 19:03:48.849  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.849  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.849执行完成index
2020-04-29 19:03:48.849  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.853  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.853开始执行count
2020-04-29 19:03:48.854  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.854开始执行index
2020-04-29 19:03:48.888  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.888执行完成count
2020-04-29 19:03:48.888  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.892  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.892开始执行count
2020-04-29 19:03:48.927  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.927执行完成count
2020-04-29 19:03:48.927  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.930  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.930执行完成index
2020-04-29 19:03:48.930  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:48.940  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.940开始执行index
2020-04-29 19:03:48.940  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.940开始执行count
2020-04-29 19:03:48.976  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.976执行完成count
2020-04-29 19:03:48.976  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:48.979  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:48.979开始执行count
2020-04-29 19:03:49.012  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.012执行完成count
2020-04-29 19:03:49.012  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.012  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.012执行完成index
2020-04-29 19:03:49.012  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.016  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.016开始执行count
2020-04-29 19:03:49.017  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.017开始执行index
2020-04-29 19:03:49.050  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.050执行完成count
2020-04-29 19:03:49.050  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.054  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.054开始执行count
2020-04-29 19:03:49.079  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.079执行完成index
2020-04-29 19:03:49.079  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.084  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.084开始执行index
2020-04-29 19:03:49.090  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.090执行完成count
2020-04-29 19:03:49.090  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.096  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.096开始执行count
2020-04-29 19:03:49.131  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.131执行完成count
2020-04-29 19:03:49.131  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.135  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.135开始执行count
2020-04-29 19:03:49.149  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.149执行完成index
2020-04-29 19:03:49.149  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.156  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.156开始执行index
2020-04-29 19:03:49.178  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.178执行完成count
2020-04-29 19:03:49.178  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.181  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.181开始执行count
2020-04-29 19:03:49.216  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.216执行完成count
2020-04-29 19:03:49.216  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.219  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.219执行完成index
2020-04-29 19:03:49.219  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.220  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.220开始执行count
2020-04-29 19:03:49.223  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.223开始执行index
2020-04-29 19:03:49.253  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.253执行完成count
2020-04-29 19:03:49.253  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.257  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.257开始执行count
2020-04-29 19:03:49.290  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.290执行完成count
2020-04-29 19:03:49.290  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.292  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.292执行完成index
2020-04-29 19:03:49.292  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.293  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.293开始执行count
2020-04-29 19:03:49.295  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.295开始执行index
2020-04-29 19:03:49.329  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.329执行完成count
2020-04-29 19:03:49.329  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.333  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.333开始执行count
2020-04-29 19:03:49.358  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.358执行完成index
2020-04-29 19:03:49.359  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.365  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.365开始执行index
2020-04-29 19:03:49.368  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.368执行完成count
2020-04-29 19:03:49.368  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.371  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.371开始执行count
2020-04-29 19:03:49.406  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.406执行完成count
2020-04-29 19:03:49.406  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.410  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.409开始执行count
2020-04-29 19:03:49.428  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.428执行完成index
2020-04-29 19:03:49.428  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.433  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.433开始执行index
2020-04-29 19:03:49.444  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.444执行完成count
2020-04-29 19:03:49.444  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.448  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.448开始执行count
2020-04-29 19:03:49.482  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.482执行完成count
2020-04-29 19:03:49.482  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.492  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.492开始执行count
2020-04-29 19:03:49.500  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.500执行完成index
2020-04-29 19:03:49.500  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.507  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.507开始执行index
2020-04-29 19:03:49.530  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.530执行完成count
2020-04-29 19:03:49.530  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.533  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.533开始执行count
2020-04-29 19:03:49.569  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.569执行完成count
2020-04-29 19:03:49.569  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.570  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.570执行完成index
2020-04-29 19:03:49.570  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.585  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.585开始执行index
2020-04-29 19:03:49.586  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.586开始执行count
2020-04-29 19:03:49.622  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.622执行完成count
2020-04-29 19:03:49.622  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.625  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.625开始执行count
2020-04-29 19:03:49.650  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.650执行完成index
2020-04-29 19:03:49.651  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.655  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.655开始执行index
2020-04-29 19:03:49.667  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.667执行完成count
2020-04-29 19:03:49.667  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.671  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.671开始执行count
2020-04-29 19:03:49.711  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.711执行完成count
2020-04-29 19:03:49.711  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.714  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.714开始执行count
2020-04-29 19:03:49.725  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.725执行完成index
2020-04-29 19:03:49.725  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.729  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.729开始执行index
2020-04-29 19:03:49.749  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.749执行完成count
2020-04-29 19:03:49.749  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.752  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.752开始执行count
2020-04-29 19:03:49.792  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.792执行完成count
2020-04-29 19:03:49.792  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.795  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.795开始执行count
2020-04-29 19:03:49.796  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.796执行完成index
2020-04-29 19:03:49.796  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.803  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.803开始执行index
2020-04-29 19:03:49.834  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.834执行完成count
2020-04-29 19:03:49.834  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.837  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.837开始执行count
2020-04-29 19:03:49.866  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.866执行完成index
2020-04-29 19:03:49.866  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.870  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.870开始执行index
2020-04-29 19:03:49.871  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.871执行完成count
2020-04-29 19:03:49.871  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.875  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.875开始执行count
2020-04-29 19:03:49.912  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.912执行完成count
2020-04-29 19:03:49.912  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.916  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.916开始执行count
2020-04-29 19:03:49.936  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.936执行完成index
2020-04-29 19:03:49.936  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:49.939  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.939开始执行index
2020-04-29 19:03:49.955  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.955执行完成count
2020-04-29 19:03:49.955  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:49.958  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.958开始执行count
2020-04-29 19:03:49.996  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:49.996执行完成count
2020-04-29 19:03:49.996  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.000  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50开始执行count
2020-04-29 19:03:50.011  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.011执行完成index
2020-04-29 19:03:50.011  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.018  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.018开始执行index
2020-04-29 19:03:50.037  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.037执行完成count
2020-04-29 19:03:50.037  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.041  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.041开始执行count
2020-04-29 19:03:50.077  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.077执行完成count
2020-04-29 19:03:50.077  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.082  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.082开始执行count
2020-04-29 19:03:50.085  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.085执行完成index
2020-04-29 19:03:50.085  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.088  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.088开始执行index
2020-04-29 19:03:50.117  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.117执行完成count
2020-04-29 19:03:50.117  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.122  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.122开始执行count
2020-04-29 19:03:50.154  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.154执行完成index
2020-04-29 19:03:50.154  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.157  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.157开始执行index
2020-04-29 19:03:50.160  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.160执行完成count
2020-04-29 19:03:50.160  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.163  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.163开始执行count
2020-04-29 19:03:50.198  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.198执行完成count
2020-04-29 19:03:50.199  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.202  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.202开始执行count
2020-04-29 19:03:50.221  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.221执行完成index
2020-04-29 19:03:50.221  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.225  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.225开始执行index
2020-04-29 19:03:50.239  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.239执行完成count
2020-04-29 19:03:50.239  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.242  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.242开始执行count
2020-04-29 19:03:50.281  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.281执行完成count
2020-04-29 19:03:50.281  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.284  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.284开始执行count
2020-04-29 19:03:50.290  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.290执行完成index
2020-04-29 19:03:50.290  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.294  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.294开始执行index
2020-04-29 19:03:50.321  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.321执行完成count
2020-04-29 19:03:50.321  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.324  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.324开始执行count
2020-04-29 19:03:50.357  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.357执行完成index
2020-04-29 19:03:50.357  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.359  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.359执行完成count
2020-04-29 19:03:50.359  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.361  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.361开始执行index
2020-04-29 19:03:50.364  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.364开始执行count
2020-04-29 19:03:50.396  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.396执行完成count
2020-04-29 19:03:50.396  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.399  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.399开始执行count
2020-04-29 19:03:50.430  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.430执行完成index
2020-04-29 19:03:50.430  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.432  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.432开始执行index
2020-04-29 19:03:50.433  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.433执行完成count
2020-04-29 19:03:50.433  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.436  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.436开始执行count
2020-04-29 19:03:50.471  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.471执行完成count
2020-04-29 19:03:50.471  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.474  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.474开始执行count
2020-04-29 19:03:50.507  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.507执行完成index
2020-04-29 19:03:50.507  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.512  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.512执行完成count
2020-04-29 19:03:50.512  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.513  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.513开始执行index
2020-04-29 19:03:50.516  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.516开始执行count
2020-04-29 19:03:50.550  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.550执行完成count
2020-04-29 19:03:50.550  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.553  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.553开始执行count
2020-04-29 19:03:50.576  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.576执行完成index
2020-04-29 19:03:50.576  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.580  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.580开始执行index
2020-04-29 19:03:50.588  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.588执行完成count
2020-04-29 19:03:50.588  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.591  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.591开始执行count
2020-04-29 19:03:50.626  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.626执行完成count
2020-04-29 19:03:50.626  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.629  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.629开始执行count
2020-04-29 19:03:50.642  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.642执行完成index
2020-04-29 19:03:50.642  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.647  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.647开始执行index
2020-04-29 19:03:50.666  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.666执行完成count
2020-04-29 19:03:50.666  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.670  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.670开始执行count
2020-04-29 19:03:50.706  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.706执行完成count
2020-04-29 19:03:50.706  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.710  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.710开始执行count
2020-04-29 19:03:50.719  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.719执行完成index
2020-04-29 19:03:50.719  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.722  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.722开始执行index
2020-04-29 19:03:50.749  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.749执行完成count
2020-04-29 19:03:50.749  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.752  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.752开始执行count
2020-04-29 19:03:50.796  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.796执行完成count
2020-04-29 19:03:50.796  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.797  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.797执行完成index
2020-04-29 19:03:50.797  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.800  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.800开始执行count
2020-04-29 19:03:50.803  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.803开始执行index
2020-04-29 19:03:50.836  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.836执行完成count
2020-04-29 19:03:50.836  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.848  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.848开始执行count
2020-04-29 19:03:50.880  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.880执行完成index
2020-04-29 19:03:50.880  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.884  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.884执行完成count
2020-04-29 19:03:50.884  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.886  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.886开始执行index
2020-04-29 19:03:50.889  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.889开始执行count
2020-04-29 19:03:50.923  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.923执行完成count
2020-04-29 19:03:50.923  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.926  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.926开始执行count
2020-04-29 19:03:50.950  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.950执行完成index
2020-04-29 19:03:50.951  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:50.953  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.953开始执行index
2020-04-29 19:03:50.961  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.961执行完成count
2020-04-29 19:03:50.961  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:50.964  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.964开始执行count
2020-04-29 19:03:50.999  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:50.999执行完成count
2020-04-29 19:03:50.999  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.003  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.003开始执行count
2020-04-29 19:03:51.016  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.016执行完成index
2020-04-29 19:03:51.016  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.019  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.019开始执行index
2020-04-29 19:03:51.037  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.037执行完成count
2020-04-29 19:03:51.037  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.041  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.041开始执行count
2020-04-29 19:03:51.077  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.077执行完成count
2020-04-29 19:03:51.077  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.082  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.082开始执行count
2020-04-29 19:03:51.082  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.082执行完成index
2020-04-29 19:03:51.082  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.089  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.089开始执行index
2020-04-29 19:03:51.119  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.119执行完成count
2020-04-29 19:03:51.119  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.122  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.122开始执行count
2020-04-29 19:03:51.155  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.155执行完成count
2020-04-29 19:03:51.155  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.157  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.157执行完成index
2020-04-29 19:03:51.157  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.158  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.158开始执行count
2020-04-29 19:03:51.161  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.161开始执行index
2020-04-29 19:03:51.195  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.195执行完成count
2020-04-29 19:03:51.195  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.199  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.199开始执行count
2020-04-29 19:03:51.224  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.224执行完成index
2020-04-29 19:03:51.224  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.231  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.231开始执行index
2020-04-29 19:03:51.234  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.234执行完成count
2020-04-29 19:03:51.234  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.237  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.237开始执行count
2020-04-29 19:03:51.275  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.275执行完成count
2020-04-29 19:03:51.275  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.281  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.281开始执行count
2020-04-29 19:03:51.303  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.303执行完成index
2020-04-29 19:03:51.303  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.307  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.307开始执行index
2020-04-29 19:03:51.318  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.318执行完成count
2020-04-29 19:03:51.318  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.323  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.323开始执行count
2020-04-29 19:03:51.359  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.359执行完成count
2020-04-29 19:03:51.359  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.363  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.363开始执行count
2020-04-29 19:03:51.373  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.373执行完成index
2020-04-29 19:03:51.373  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.377  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.377开始执行index
2020-04-29 19:03:51.404  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.404执行完成count
2020-04-29 19:03:51.404  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.407  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.407开始执行count
2020-04-29 19:03:51.453  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.453执行完成count
2020-04-29 19:03:51.453  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.456  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.456开始执行count
2020-04-29 19:03:51.458  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.458执行完成index
2020-04-29 19:03:51.458  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.461  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.461开始执行index
2020-04-29 19:03:51.506  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.506执行完成count
2020-04-29 19:03:51.506  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.515  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.514开始执行count
2020-04-29 19:03:51.557  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.557执行完成index
2020-04-29 19:03:51.557  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.561  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.561开始执行index
2020-04-29 19:03:51.570  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.570执行完成count
2020-04-29 19:03:51.570  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.573  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.573开始执行count
2020-04-29 19:03:51.620  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.620执行完成count
2020-04-29 19:03:51.620  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.623  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.623开始执行count
2020-04-29 19:03:51.648  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.648执行完成index
2020-04-29 19:03:51.648  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.653  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.653开始执行index
2020-04-29 19:03:51.668  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.668执行完成count
2020-04-29 19:03:51.668  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.671  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.671开始执行count
2020-04-29 19:03:51.713  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.713执行完成count
2020-04-29 19:03:51.713  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.716  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.716开始执行count
2020-04-29 19:03:51.732  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.732执行完成index
2020-04-29 19:03:51.732  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.735  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.735开始执行index
2020-04-29 19:03:51.756  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.756执行完成count
2020-04-29 19:03:51.756  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.760  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.760开始执行count
2020-04-29 19:03:51.796  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.796执行完成count
2020-04-29 19:03:51.796  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.800  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.800开始执行count
2020-04-29 19:03:51.808  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.808执行完成index
2020-04-29 19:03:51.808  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.813  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.813开始执行index
2020-04-29 19:03:51.834  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.834执行完成count
2020-04-29 19:03:51.834  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.838  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.838开始执行count
2020-04-29 19:03:51.872  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.872执行完成count
2020-04-29 19:03:51.872  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.876  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.876开始执行count
2020-04-29 19:03:51.876  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.876执行完成index
2020-04-29 19:03:51.876  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.879  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.879开始执行index
2020-04-29 19:03:51.911  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.911执行完成count
2020-04-29 19:03:51.911  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.914  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.914开始执行count
2020-04-29 19:03:51.942  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.942执行完成index
2020-04-29 19:03:51.942  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:51.948  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.948开始执行index
2020-04-29 19:03:51.948  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.948执行完成count
2020-04-29 19:03:51.948  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.952  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.952开始执行count
2020-04-29 19:03:51.987  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.987执行完成count
2020-04-29 19:03:51.987  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:51.993  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:51.993开始执行count
2020-04-29 19:03:52.016  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.016执行完成index
2020-04-29 19:03:52.016  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.021  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.021开始执行index
2020-04-29 19:03:52.029  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.029执行完成count
2020-04-29 19:03:52.029  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.033  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.033开始执行count
2020-04-29 19:03:52.069  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.069执行完成count
2020-04-29 19:03:52.069  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.072  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.072开始执行count
2020-04-29 19:03:52.085  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.085执行完成index
2020-04-29 19:03:52.085  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.090  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.090开始执行index
2020-04-29 19:03:52.107  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.107执行完成count
2020-04-29 19:03:52.107  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.111  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.111开始执行count
2020-04-29 19:03:52.146  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.146执行完成count
2020-04-29 19:03:52.146  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.149  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.149开始执行count
2020-04-29 19:03:52.152  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.152执行完成index
2020-04-29 19:03:52.152  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.154  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.154开始执行index
2020-04-29 19:03:52.185  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.185执行完成count
2020-04-29 19:03:52.185  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.196  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.196开始执行count
2020-04-29 19:03:52.218  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.218执行完成index
2020-04-29 19:03:52.218  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.222  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.222开始执行index
2020-04-29 19:03:52.230  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.230执行完成count
2020-04-29 19:03:52.230  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.233  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.233开始执行count
2020-04-29 19:03:52.268  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.268执行完成count
2020-04-29 19:03:52.268  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.272  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.272开始执行count
2020-04-29 19:03:52.285  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.285执行完成index
2020-04-29 19:03:52.285  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.291  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.291开始执行index
2020-04-29 19:03:52.307  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.307执行完成count
2020-04-29 19:03:52.307  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.311  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.311开始执行count
2020-04-29 19:03:52.345  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.345执行完成count
2020-04-29 19:03:52.345  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.349  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.349开始执行count
2020-04-29 19:03:52.355  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.355执行完成index
2020-04-29 19:03:52.355  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.361  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.361开始执行index
2020-04-29 19:03:52.387  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.387执行完成count
2020-04-29 19:03:52.387  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.390  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.390开始执行count
2020-04-29 19:03:52.430  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.430执行完成count
2020-04-29 19:03:52.430  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.431  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.431执行完成index
2020-04-29 19:03:52.431  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.433  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.433开始执行count
2020-04-29 19:03:52.435  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.435开始执行index
2020-04-29 19:03:52.470  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.470执行完成count
2020-04-29 19:03:52.470  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.473  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.473开始执行count
2020-04-29 19:03:52.505  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.505执行完成count
2020-04-29 19:03:52.505  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.508  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.508执行完成index
2020-04-29 19:03:52.508  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.509  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.509开始执行count
2020-04-29 19:03:52.511  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.511开始执行index
2020-04-29 19:03:52.545  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.545执行完成count
2020-04-29 19:03:52.545  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.548  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.548开始执行count
2020-04-29 19:03:52.574  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.574执行完成index
2020-04-29 19:03:52.574  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.577  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.577开始执行index
2020-04-29 19:03:52.582  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.582执行完成count
2020-04-29 19:03:52.582  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.585  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.585开始执行count
2020-04-29 19:03:52.621  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.621执行完成count
2020-04-29 19:03:52.621  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.624  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.624开始执行count
2020-04-29 19:03:52.640  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.640执行完成index
2020-04-29 19:03:52.641  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.643  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.643开始执行index
2020-04-29 19:03:52.658  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.658执行完成count
2020-04-29 19:03:52.658  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.661  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.661开始执行count
2020-04-29 19:03:52.697  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.697执行完成count
2020-04-29 19:03:52.698  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.702  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.702开始执行count
2020-04-29 19:03:52.706  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.705执行完成index
2020-04-29 19:03:52.706  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.708  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.708开始执行index
2020-04-29 19:03:52.741  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.741执行完成count
2020-04-29 19:03:52.741  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.751  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.751开始执行count
2020-04-29 19:03:52.783  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.783执行完成index
2020-04-29 19:03:52.783  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.789  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.789开始执行index
2020-04-29 19:03:52.792  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.792执行完成count
2020-04-29 19:03:52.792  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.799  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.799开始执行count
2020-04-29 19:03:52.836  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.836执行完成count
2020-04-29 19:03:52.836  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.839  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.839开始执行count
2020-04-29 19:03:52.853  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.853执行完成index
2020-04-29 19:03:52.853  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.859  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.859开始执行index
2020-04-29 19:03:52.874  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.874执行完成count
2020-04-29 19:03:52.875  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.878  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.878开始执行count
2020-04-29 19:03:52.913  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.913执行完成count
2020-04-29 19:03:52.913  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.916  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.916开始执行count
2020-04-29 19:03:52.922  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.922执行完成index
2020-04-29 19:03:52.922  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.928  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.928开始执行index
2020-04-29 19:03:52.951  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.951执行完成count
2020-04-29 19:03:52.951  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.954  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.954开始执行count
2020-04-29 19:03:52.988  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.988执行完成count
2020-04-29 19:03:52.988  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:52.990  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.990执行完成index
2020-04-29 19:03:52.990  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:52.992  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.992开始执行count
2020-04-29 19:03:52.993  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:52.993开始执行index
2020-04-29 19:03:53.024  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.024执行完成count
2020-04-29 19:03:53.024  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.028  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.028开始执行count
2020-04-29 19:03:53.060  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.060执行完成count
2020-04-29 19:03:53.060  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.063  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.063执行完成index
2020-04-29 19:03:53.063  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.064  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.064开始执行count
2020-04-29 19:03:53.070  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.070开始执行index
2020-04-29 19:03:53.103  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.103执行完成count
2020-04-29 19:03:53.103  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.106  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.106开始执行count
2020-04-29 19:03:53.132  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.132执行完成index
2020-04-29 19:03:53.132  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.137  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.137开始执行index
2020-04-29 19:03:53.141  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.141执行完成count
2020-04-29 19:03:53.141  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.144  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.144开始执行count
2020-04-29 19:03:53.178  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.178执行完成count
2020-04-29 19:03:53.178  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.182  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.182开始执行count
2020-04-29 19:03:53.199  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.199执行完成index
2020-04-29 19:03:53.199  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.201  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.201开始执行index
2020-04-29 19:03:53.216  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.216执行完成count
2020-04-29 19:03:53.216  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.219  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.219开始执行count
2020-04-29 19:03:53.254  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.254执行完成count
2020-04-29 19:03:53.254  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.257  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.257开始执行count
2020-04-29 19:03:53.264  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.264执行完成index
2020-04-29 19:03:53.264  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.270  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.270开始执行index
2020-04-29 19:03:53.292  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.292执行完成count
2020-04-29 19:03:53.292  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.295  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.295开始执行count
2020-04-29 19:03:53.331  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.331执行完成count
2020-04-29 19:03:53.331  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.334  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.334执行完成index
2020-04-29 19:03:53.334  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.336  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.336开始执行count
2020-04-29 19:03:53.337  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.337开始执行index
2020-04-29 19:03:53.370  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.370执行完成count
2020-04-29 19:03:53.370  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.373  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.373开始执行count
2020-04-29 19:03:53.407  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.407执行完成count
2020-04-29 19:03:53.407  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.409  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.409执行完成index
2020-04-29 19:03:53.409  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.410  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.410开始执行count
2020-04-29 19:03:53.412  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.412开始执行index
2020-04-29 19:03:53.445  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.445执行完成count
2020-04-29 19:03:53.445  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.448  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.448开始执行count
2020-04-29 19:03:53.475  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.475执行完成index
2020-04-29 19:03:53.475  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.480  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.480开始执行index
2020-04-29 19:03:53.488  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.488执行完成count
2020-04-29 19:03:53.489  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.492  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.492开始执行count
2020-04-29 19:03:53.529  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.529执行完成count
2020-04-29 19:03:53.529  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.532  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.532开始执行count
2020-04-29 19:03:53.542  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.542执行完成index
2020-04-29 19:03:53.542  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.544  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.544开始执行index
2020-04-29 19:03:53.569  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.569执行完成count
2020-04-29 19:03:53.569  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.572  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.572开始执行count
2020-04-29 19:03:53.607  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.607执行完成count
2020-04-29 19:03:53.607  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.607  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.607执行完成index
2020-04-29 19:03:53.607  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.609  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.609开始执行index
2020-04-29 19:03:53.610  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.610开始执行count
2020-04-29 19:03:53.645  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.645执行完成count
2020-04-29 19:03:53.645  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.648  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.648开始执行count
2020-04-29 19:03:53.672  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.672执行完成index
2020-04-29 19:03:53.672  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.675  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.675开始执行index
2020-04-29 19:03:53.682  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.682执行完成count
2020-04-29 19:03:53.682  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.685  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.685开始执行count
2020-04-29 19:03:53.720  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.720执行完成count
2020-04-29 19:03:53.720  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.723  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.723开始执行count
2020-04-29 19:03:53.740  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.740执行完成index
2020-04-29 19:03:53.740  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.747  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.747开始执行index
2020-04-29 19:03:53.758  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.758执行完成count
2020-04-29 19:03:53.758  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.762  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.762开始执行count
2020-04-29 19:03:53.796  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.796执行完成count
2020-04-29 19:03:53.796  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.799  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.799开始执行count
2020-04-29 19:03:53.810  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.810执行完成index
2020-04-29 19:03:53.810  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.812  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.812开始执行index
2020-04-29 19:03:53.834  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.834执行完成count
2020-04-29 19:03:53.834  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.838  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.838开始执行count
2020-04-29 19:03:53.876  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.876执行完成count
2020-04-29 19:03:53.876  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.878  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.878执行完成index
2020-04-29 19:03:53.878  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.880  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.880开始执行count
2020-04-29 19:03:53.881  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.881开始执行index
2020-04-29 19:03:53.919  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.919执行完成count
2020-04-29 19:03:53.919  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.923  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.923开始执行count
2020-04-29 19:03:53.958  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.958执行完成count
2020-04-29 19:03:53.958  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.959  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.959执行完成index
2020-04-29 19:03:53.960  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:53.961  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.961开始执行count
2020-04-29 19:03:53.962  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.962开始执行index
2020-04-29 19:03:53.993  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.993执行完成count
2020-04-29 19:03:53.993  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:53.996  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:53.996开始执行count
2020-04-29 19:03:54.030  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.030执行完成index
2020-04-29 19:03:54.030  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.033  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.033开始执行index
2020-04-29 19:03:54.039  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.039执行完成count
2020-04-29 19:03:54.039  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.042  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.042开始执行count
2020-04-29 19:03:54.074  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.074执行完成count
2020-04-29 19:03:54.074  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.077  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.077开始执行count
2020-04-29 19:03:54.102  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.102执行完成index
2020-04-29 19:03:54.102  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.108  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.108开始执行index
2020-04-29 19:03:54.109  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.109执行完成count
2020-04-29 19:03:54.109  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.113  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.112开始执行count
2020-04-29 19:03:54.154  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.154执行完成count
2020-04-29 19:03:54.154  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.157  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.157开始执行count
2020-04-29 19:03:54.177  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.177执行完成index
2020-04-29 19:03:54.177  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.182  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.182开始执行index
2020-04-29 19:03:54.189  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.189执行完成count
2020-04-29 19:03:54.189  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.196  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.196开始执行count
2020-04-29 19:03:54.228  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.228执行完成count
2020-04-29 19:03:54.228  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.232  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.232开始执行count
2020-04-29 19:03:54.252  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.252执行完成index
2020-04-29 19:03:54.252  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.259  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.259开始执行index
2020-04-29 19:03:54.264  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.264执行完成count
2020-04-29 19:03:54.264  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.266  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.266开始执行count
2020-04-29 19:03:54.298  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.298执行完成count
2020-04-29 19:03:54.298  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.301  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.301开始执行count
2020-04-29 19:03:54.327  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.327执行完成index
2020-04-29 19:03:54.327  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.332  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.332开始执行index
2020-04-29 19:03:54.333  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.333执行完成count
2020-04-29 19:03:54.333  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.337  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.337开始执行count
2020-04-29 19:03:54.369  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.369执行完成count
2020-04-29 19:03:54.369  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.373  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.373开始执行count
2020-04-29 19:03:54.401  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.401执行完成index
2020-04-29 19:03:54.401  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.406  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.406开始执行index
2020-04-29 19:03:54.406  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.406执行完成count
2020-04-29 19:03:54.406  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.409  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.409开始执行count
2020-04-29 19:03:54.448  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.448执行完成count
2020-04-29 19:03:54.448  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.451  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.451开始执行count
2020-04-29 19:03:54.479  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.479执行完成index
2020-04-29 19:03:54.480  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.488  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.488开始执行index
2020-04-29 19:03:54.489  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.489执行完成count
2020-04-29 19:03:54.490  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.498  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.498开始执行count
2020-04-29 19:03:54.536  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.536执行完成count
2020-04-29 19:03:54.536  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.539  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.539开始执行count
2020-04-29 19:03:54.555  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.555执行完成index
2020-04-29 19:03:54.555  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.559  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.559开始执行index
2020-04-29 19:03:54.575  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.575执行完成count
2020-04-29 19:03:54.575  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.582  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.582开始执行count
2020-04-29 19:03:54.620  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.620执行完成count
2020-04-29 19:03:54.620  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.624  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.624执行完成index
2020-04-29 19:03:54.624  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.627  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.627开始执行count
2020-04-29 19:03:54.631  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.631开始执行index
2020-04-29 19:03:54.662  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.662执行完成count
2020-04-29 19:03:54.663  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.672  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.672开始执行count
2020-04-29 19:03:54.706  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.706执行完成index
2020-04-29 19:03:54.706  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.707  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.707执行完成count
2020-04-29 19:03:54.707  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.709  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.709开始执行index
2020-04-29 19:03:54.711  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.710开始执行count
2020-04-29 19:03:54.745  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.745执行完成count
2020-04-29 19:03:54.745  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.749  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.749开始执行count
2020-04-29 19:03:54.771  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.771执行完成index
2020-04-29 19:03:54.771  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.777  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.777开始执行index
2020-04-29 19:03:54.783  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.783执行完成count
2020-04-29 19:03:54.783  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.786  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.786开始执行count
2020-04-29 19:03:54.821  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.821执行完成count
2020-04-29 19:03:54.821  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.824  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.824开始执行count
2020-04-29 19:03:54.839  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.839执行完成index
2020-04-29 19:03:54.839  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.844  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.844开始执行index
2020-04-29 19:03:54.858  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.858执行完成count
2020-04-29 19:03:54.858  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.861  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.861开始执行count
2020-04-29 19:03:54.895  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.895执行完成count
2020-04-29 19:03:54.895  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.899  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.899开始执行count
2020-04-29 19:03:54.905  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.905执行完成index
2020-04-29 19:03:54.905  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.908  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.908开始执行index
2020-04-29 19:03:54.939  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.939执行完成count
2020-04-29 19:03:54.939  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.942  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.942开始执行count
2020-04-29 19:03:54.978  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.978执行完成index
2020-04-29 19:03:54.978  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.978执行完成count
2020-04-29 19:03:54.978  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:54.978  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:54.981  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.981开始执行count
2020-04-29 19:03:54.983  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:54.983开始执行index
2020-04-29 19:03:55.017  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.017执行完成count
2020-04-29 19:03:55.017  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.020  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.020开始执行count
2020-04-29 19:03:55.053  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.053执行完成count
2020-04-29 19:03:55.053  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.055  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.055执行完成index
2020-04-29 19:03:55.055  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.057  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.057开始执行count
2020-04-29 19:03:55.059  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.059开始执行index
2020-04-29 19:03:55.096  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.096执行完成count
2020-04-29 19:03:55.096  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.099  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.099开始执行count
2020-04-29 19:03:55.127  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.127执行完成index
2020-04-29 19:03:55.127  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.130  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.130开始执行index
2020-04-29 19:03:55.135  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.135执行完成count
2020-04-29 19:03:55.135  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.139  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.139开始执行count
2020-04-29 19:03:55.174  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.174执行完成count
2020-04-29 19:03:55.174  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.177  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.177开始执行count
2020-04-29 19:03:55.195  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.195执行完成index
2020-04-29 19:03:55.195  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.202  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.202开始执行index
2020-04-29 19:03:55.212  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.212执行完成count
2020-04-29 19:03:55.212  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.216  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.216开始执行count
2020-04-29 19:03:55.252  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.252执行完成count
2020-04-29 19:03:55.253  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.263  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.263开始执行count
2020-04-29 19:03:55.266  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.266执行完成index
2020-04-29 19:03:55.266  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.272  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.272开始执行index
2020-04-29 19:03:55.301  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.301执行完成count
2020-04-29 19:03:55.301  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.305  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.305开始执行count
2020-04-29 19:03:55.336  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.336执行完成index
2020-04-29 19:03:55.336  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.341  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.341执行完成count
2020-04-29 19:03:55.341  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.345  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.345开始执行index
2020-04-29 19:03:55.348  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.348开始执行count
2020-04-29 19:03:55.381  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.381执行完成count
2020-04-29 19:03:55.381  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.384  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.384开始执行count
2020-04-29 19:03:55.412  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.412执行完成index
2020-04-29 19:03:55.412  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.417  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.417执行完成count
2020-04-29 19:03:55.417  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.418  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.418开始执行index
2020-04-29 19:03:55.422  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.422开始执行count
2020-04-29 19:03:55.458  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.458执行完成count
2020-04-29 19:03:55.458  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.461  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.461开始执行count
2020-04-29 19:03:55.481  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.481执行完成index
2020-04-29 19:03:55.481  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.485  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.485开始执行index
2020-04-29 19:03:55.497  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.497执行完成count
2020-04-29 19:03:55.497  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.500  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.500开始执行count
2020-04-29 19:03:55.535  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.535执行完成count
2020-04-29 19:03:55.535  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.538  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.538开始执行count
2020-04-29 19:03:55.550  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.550执行完成index
2020-04-29 19:03:55.550  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.555  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.555开始执行index
2020-04-29 19:03:55.573  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.573执行完成count
2020-04-29 19:03:55.573  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.576  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.576开始执行count
2020-04-29 19:03:55.611  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.611执行完成count
2020-04-29 19:03:55.611  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.614  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.614开始执行count
2020-04-29 19:03:55.617  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.617执行完成index
2020-04-29 19:03:55.617  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.619  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.619开始执行index
2020-04-29 19:03:55.650  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.650执行完成count
2020-04-29 19:03:55.650  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.654  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.654开始执行count
2020-04-29 19:03:55.685  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.685执行完成index
2020-04-29 19:03:55.685  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.690  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.690执行完成count
2020-04-29 19:03:55.690  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.691  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.691开始执行index
2020-04-29 19:03:55.694  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.694开始执行count
2020-04-29 19:03:55.726  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.726执行完成count
2020-04-29 19:03:55.726  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.729  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.729开始执行count
2020-04-29 19:03:55.757  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.757执行完成index
2020-04-29 19:03:55.758  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.763  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.763执行完成count
2020-04-29 19:03:55.763  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.765  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.765开始执行index
2020-04-29 19:03:55.768  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.768开始执行count
2020-04-29 19:03:55.803  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.803执行完成count
2020-04-29 19:03:55.803  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.806  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.806开始执行count
2020-04-29 19:03:55.828  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.828执行完成index
2020-04-29 19:03:55.828  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.832  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.832开始执行index
2020-04-29 19:03:55.841  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.841执行完成count
2020-04-29 19:03:55.841  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.845  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.845开始执行count
2020-04-29 19:03:55.880  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.880执行完成count
2020-04-29 19:03:55.880  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.883  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.883开始执行count
2020-04-29 19:03:55.895  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.895执行完成index
2020-04-29 19:03:55.896  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.901  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.901开始执行index
2020-04-29 19:03:55.917  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.917执行完成count
2020-04-29 19:03:55.917  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.920  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.920开始执行count
2020-04-29 19:03:55.954  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.954执行完成count
2020-04-29 19:03:55.954  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.957  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.957开始执行count
2020-04-29 19:03:55.964  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.964执行完成index
2020-04-29 19:03:55.964  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:55.970  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.970开始执行index
2020-04-29 19:03:55.992  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.992执行完成count
2020-04-29 19:03:55.992  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:55.995  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:55.995开始执行count
2020-04-29 19:03:56.030  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.030执行完成count
2020-04-29 19:03:56.031  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.033  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.033执行完成index
2020-04-29 19:03:56.034  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.045  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.045开始执行count
2020-04-29 19:03:56.061  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.061开始执行index
2020-04-29 19:03:56.091  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.091执行完成count
2020-04-29 19:03:56.091  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.100  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.100开始执行count
2020-04-29 19:03:56.129  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.129执行完成index
2020-04-29 19:03:56.129  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.131  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.131执行完成count
2020-04-29 19:03:56.131  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.132  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.132开始执行index
2020-04-29 19:03:56.135  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.135开始执行count
2020-04-29 19:03:56.170  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.170执行完成count
2020-04-29 19:03:56.170  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.173  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.173开始执行count
2020-04-29 19:03:56.195  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.195执行完成index
2020-04-29 19:03:56.195  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.198  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.198开始执行index
2020-04-29 19:03:56.207  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.207执行完成count
2020-04-29 19:03:56.207  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.209  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.209开始执行count
2020-04-29 19:03:56.244  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.244执行完成count
2020-04-29 19:03:56.244  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.247  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.247开始执行count
2020-04-29 19:03:56.261  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.261执行完成index
2020-04-29 19:03:56.261  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.265  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.265开始执行index
2020-04-29 19:03:56.284  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.284执行完成count
2020-04-29 19:03:56.285  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.288  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.288开始执行count
2020-04-29 19:03:56.323  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.323执行完成count
2020-04-29 19:03:56.323  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.326  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.326开始执行count
2020-04-29 19:03:56.330  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.330执行完成index
2020-04-29 19:03:56.330  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.332  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.332开始执行index
2020-04-29 19:03:56.360  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.360执行完成count
2020-04-29 19:03:56.360  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.364  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.364开始执行count
2020-04-29 19:03:56.395  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.395执行完成index
2020-04-29 19:03:56.395  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.398  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.398执行完成count
2020-04-29 19:03:56.398  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.400  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.400开始执行index
2020-04-29 19:03:56.402  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.402开始执行count
2020-04-29 19:03:56.434  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.434执行完成count
2020-04-29 19:03:56.434  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.437  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.437开始执行count
2020-04-29 19:03:56.468  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.468执行完成count
2020-04-29 19:03:56.468  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.468  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.468执行完成index
2020-04-29 19:03:56.468  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.471  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.471开始执行count
2020-04-29 19:03:56.472  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.472开始执行index
2020-04-29 19:03:56.506  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.506执行完成count
2020-04-29 19:03:56.506  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.509  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.509开始执行count
2020-04-29 19:03:56.535  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.535执行完成index
2020-04-29 19:03:56.535  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.540  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.540开始执行index
2020-04-29 19:03:56.543  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.543执行完成count
2020-04-29 19:03:56.543  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.546  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.546开始执行count
2020-04-29 19:03:56.580  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.580执行完成count
2020-04-29 19:03:56.580  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.583  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.583开始执行count
2020-04-29 19:03:56.602  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.602执行完成index
2020-04-29 19:03:56.602  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.607  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.607开始执行index
2020-04-29 19:03:56.618  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.618执行完成count
2020-04-29 19:03:56.618  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.622  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.622开始执行count
2020-04-29 19:03:56.659  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.659执行完成count
2020-04-29 19:03:56.659  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.663  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.663开始执行count
2020-04-29 19:03:56.673  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.673执行完成index
2020-04-29 19:03:56.674  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.676  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.676开始执行index
2020-04-29 19:03:56.697  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.697执行完成count
2020-04-29 19:03:56.697  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.701  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.701开始执行count
2020-04-29 19:03:56.737  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.736执行完成count
2020-04-29 19:03:56.737  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.740  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.740执行完成index
2020-04-29 19:03:56.740  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.745  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.745开始执行count
2020-04-29 19:03:56.746  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.746开始执行index
2020-04-29 19:03:56.777  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.777执行完成count
2020-04-29 19:03:56.777  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.794  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.794开始执行count
2020-04-29 19:03:56.814  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.814执行完成index
2020-04-29 19:03:56.814  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.819  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.819开始执行index
2020-04-29 19:03:56.827  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.827执行完成count
2020-04-29 19:03:56.827  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.832  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.832开始执行count
2020-04-29 19:03:56.864  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.864执行完成count
2020-04-29 19:03:56.864  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.869  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.869开始执行count
2020-04-29 19:03:56.892  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.892执行完成index
2020-04-29 19:03:56.892  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.897  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.897开始执行index
2020-04-29 19:03:56.903  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.903执行完成count
2020-04-29 19:03:56.903  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.910  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.910开始执行count
2020-04-29 19:03:56.944  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.944执行完成count
2020-04-29 19:03:56.944  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.947  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.947开始执行count
2020-04-29 19:03:56.966  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.966执行完成index
2020-04-29 19:03:56.966  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:56.972  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.972开始执行index
2020-04-29 19:03:56.981  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.981执行完成count
2020-04-29 19:03:56.981  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:56.984  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:56.984开始执行count
2020-04-29 19:03:57.016  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:03:57.016执行完成count
2020-04-29 19:03:57.016  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:03:57.020  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:57.020开始执行count
2020-04-29 19:03:57.040  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:03:57.040执行完成index
2020-04-29 19:03:57.040  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:03:57.053  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:03:57.053执行完成count
2020-04-29 19:03:57.053  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:04:15.871  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:04:15.871开始执行count
2020-04-29 19:04:15.903  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:04:15.903执行完成count
2020-04-29 19:04:15.903  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:04:15.908  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:04:15.908开始执行index
2020-04-29 19:04:15.970  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:04:15.970执行完成index
2020-04-29 19:04:15.970  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:04:23.176  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:04:23.176开始执行count
2020-04-29 19:04:23.176  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:04:23.176开始执行index
2020-04-29 19:04:23.208  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:04:23.208执行完成count
2020-04-29 19:04:23.208  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:4
2020-04-29 19:04:23.246  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:04:23.246执行完成index
2020-04-29 19:04:23.246  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:04:23.250  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:04:23.250开始执行index
2020-04-29 19:04:23.318  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:04:23.318执行完成index
2020-04-29 19:04:23.318  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:04:45.514  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:04:45.514开始执行count
2020-04-29 19:04:45.548  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:04:45.548执行完成count
2020-04-29 19:04:45.548  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:04:45.552  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:04:45.552开始执行index
2020-04-29 19:04:45.619  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:04:45.619执行完成index
2020-04-29 19:04:45.620  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:05:42.929  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:05:42.929开始执行blogPage
2020-04-29 19:05:42.930  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:05:42.930开始执行getAllType
2020-04-29 19:05:43.005  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:05:43.005执行完成blogPage
2020-04-29 19:05:43.005  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:05:43.011  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:05:43.011执行完成getAllType
2020-04-29 19:05:43.011  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:07:25.939  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 19:07:25.939  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 19:07:28.630  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 19:07:28.800  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 2.89 seconds (JVM running for 1712.349)
2020-04-29 19:08:18.824  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:08:18.824开始执行blogPage
2020-04-29 19:08:18.826  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:08:18.826开始执行getAllType
2020-04-29 19:08:18.868  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:08:18.868执行完成getAllType
2020-04-29 19:08:18.868  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:08:18.900  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:08:18.900执行完成blogPage
2020-04-29 19:08:18.902  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:08:20.207  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 19:08:20.207  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 19:08:22.856  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 19:08:23.030  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 2.861 seconds (JVM running for 1766.58)
2020-04-29 19:10:29.910  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:10:29.910开始执行blogPage
2020-04-29 19:10:29.912  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:10:29.912开始执行getAllType
2020-04-29 19:10:29.986  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:10:29.986执行完成getAllType
2020-04-29 19:10:29.986  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:10:30.023  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:10:30.023执行完成blogPage
2020-04-29 19:10:30.023  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:10:57.357  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:10:57.357开始执行typePage
2020-04-29 19:10:57.427  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:10:57.427执行完成typePage
2020-04-29 19:10:57.427  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:11:21.516  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:11:21.516开始执行typePage
2020-04-29 19:11:21.582  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:11:21.582执行完成typePage
2020-04-29 19:11:21.582  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:11:21.683  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:11:21.683开始执行typePage
2020-04-29 19:11:21.750  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:11:21.750执行完成typePage
2020-04-29 19:11:21.750  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:11:21.935  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:11:21.935开始执行typePage
2020-04-29 19:11:22.001  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:11:22.001执行完成typePage
2020-04-29 19:11:22.001  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:11:22.150  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:11:22.150开始执行typePage
2020-04-29 19:11:22.218  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:11:22.218执行完成typePage
2020-04-29 19:11:22.218  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:11:23.978  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:11:23.978开始执行blogPage
2020-04-29 19:11:23.979  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:11:23.979开始执行getAllType
2020-04-29 19:11:24.013  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:11:24.013执行完成getAllType
2020-04-29 19:11:24.013  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:11:24.047  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:11:24.047执行完成blogPage
2020-04-29 19:11:24.050  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:11:32.013  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:11:32.013开始执行blogPage
2020-04-29 19:11:32.080  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:11:32.080执行完成blogPage
2020-04-29 19:11:32.085  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:23:52.046  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:23:52.046开始执行blogPage
2020-04-29 19:23:52.048  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:23:52.048开始执行getAllType
2020-04-29 19:23:53.438  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:23:53.438开始执行blogPage
2020-04-29 19:23:53.440  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:23:53.440开始执行getAllType
2020-04-29 19:23:53.500  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:23:53.500执行完成blogPage
2020-04-29 19:23:53.503  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:23:54.114  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:23:54.114执行完成blogPage
2020-04-29 19:23:54.115  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:23:54.120 ERROR 20696 --- [http-nio-80-exec-2] c.b.handler.ControllerExceptionHandler   : Request URL : http://localhost/blog/blog/admin/blogPage,EXxception : {}

org.apache.catalina.connector.ClientAbortException: java.io.IOException: 你的主机中的软件中止了一个已建立的连接。
	at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:309) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.OutputBuffer.flush(OutputBuffer.java:272) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteOutputStream.flush(CoyoteOutputStream.java:118) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.fasterxml.jackson.core.json.UTF8JsonGenerator.flush(UTF8JsonGenerator.java:1153) ~[jackson-core-2.10.3.jar:2.10.3]
	at com.fasterxml.jackson.databind.ObjectWriter.writeValue(ObjectWriter.java:923) ~[jackson-databind-2.10.3.jar:2.10.3]
	at org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.writeInternal(AbstractJackson2HttpMessageConverter.java:287) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.http.converter.AbstractGenericHttpMessageConverter.write(AbstractGenericHttpMessageConverter.java:104) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor.writeWithMessageConverters(AbstractMessageConverterMethodProcessor.java:287) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.handleReturnValue(RequestResponseBodyMethodProcessor.java:181) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite.handleReturnValue(HandlerMethodReturnValueHandlerComposite.java:82) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:123) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: java.io.IOException: 你的主机中的软件中止了一个已建立的连接。
	at sun.nio.ch.SocketDispatcher.write0(Native Method) ~[na:1.8.0_131]
	at sun.nio.ch.SocketDispatcher.write(SocketDispatcher.java:51) ~[na:1.8.0_131]
	at sun.nio.ch.IOUtil.writeFromNativeBuffer(IOUtil.java:93) ~[na:1.8.0_131]
	at sun.nio.ch.IOUtil.write(IOUtil.java:65) ~[na:1.8.0_131]
	at sun.nio.ch.SocketChannelImpl.write(SocketChannelImpl.java:471) ~[na:1.8.0_131]
	at org.apache.tomcat.util.net.NioChannel.write(NioChannel.java:138) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioBlockingSelector.write(NioBlockingSelector.java:101) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioSelectorPool.write(NioSelectorPool.java:152) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper.doWrite(NioEndpoint.java:1253) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketWrapperBase.doWrite(SocketWrapperBase.java:740) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketWrapperBase.flushBlocking(SocketWrapperBase.java:693) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketWrapperBase.flush(SocketWrapperBase.java:683) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11OutputBuffer$SocketOutputBuffer.flush(Http11OutputBuffer.java:564) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.filters.ChunkedOutputFilter.flush(ChunkedOutputFilter.java:157) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11OutputBuffer.flush(Http11OutputBuffer.java:217) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.flush(Http11Processor.java:1155) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessor.action(AbstractProcessor.java:398) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.Response.action(Response.java:209) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.OutputBuffer.doFlush(OutputBuffer.java:305) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	... 56 common frames omitted

2020-04-29 19:23:54.124  WARN 20696 --- [http-nio-80-exec-2] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.apache.catalina.connector.ClientAbortException: java.io.IOException: 你的主机中的软件中止了一个已建立的连接。]
2020-04-29 19:23:54.128 ERROR 20696 --- [http-nio-80-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalStateException: getOutputStream() has already been called for this response] with root cause

java.lang.IllegalStateException: getOutputStream() has already been called for this response
	at org.apache.catalina.connector.Response.getWriter(Response.java:582) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.ResponseFacade.getWriter(ResponseFacade.java:227) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at javax.servlet.ServletResponseWrapper.getWriter(ServletResponseWrapper.java:114) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:360) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 19:23:54.147  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:23:54.147执行完成getAllType
2020-04-29 19:23:54.147  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:23:54.476  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:23:54.476执行完成getAllType
2020-04-29 19:23:54.476  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:23:55.465  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 19:23:55.465  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 19:23:58.222  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 19:23:58.386  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 2.941 seconds (JVM running for 2701.936)
2020-04-29 19:23:58.442  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:23:58.442开始执行blogPage
2020-04-29 19:23:58.529  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:23:58.529执行完成blogPage
2020-04-29 19:23:58.529  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:24:04.010  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:24:04.010开始执行blogPage
2020-04-29 19:24:04.076  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:24:04.076执行完成blogPage
2020-04-29 19:24:04.076  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=1, data=[Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:24:08.010  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:24:08.010开始执行blogPage
2020-04-29 19:24:08.078  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:24:08.078执行完成blogPage
2020-04-29 19:24:08.082  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:24:51.539  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:24:51.539开始执行blogPage
2020-04-29 19:24:51.605  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:24:51.605执行完成blogPage
2020-04-29 19:24:51.605  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:25:02.104  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:25:02.104开始执行blogPage
2020-04-29 19:25:02.169  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:25:02.169执行完成blogPage
2020-04-29 19:25:02.171  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:25:26.908  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:25:26.908开始执行blogPage
2020-04-29 19:25:26.909  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:25:26.909开始执行getAllType
2020-04-29 19:25:26.976  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:25:26.976执行完成blogPage
2020-04-29 19:25:26.978  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:25:26.981  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:25:26.981执行完成getAllType
2020-04-29 19:25:26.981  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:25:35.883  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:25:35.883开始执行blogPage
2020-04-29 19:25:35.886  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:25:35.886开始执行getAllType
2020-04-29 19:25:35.921  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:25:35.921执行完成getAllType
2020-04-29 19:25:35.921  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:25:35.947  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:25:35.947执行完成blogPage
2020-04-29 19:25:35.948  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:25:36.601  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:25:36.601开始执行blogPage
2020-04-29 19:25:36.602  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:25:36.602开始执行getAllType
2020-04-29 19:25:36.642  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:25:36.642执行完成getAllType
2020-04-29 19:25:36.642  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:25:36.666  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:25:36.666执行完成blogPage
2020-04-29 19:25:36.670  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:26:17.842  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:26:17.842开始执行blogPage
2020-04-29 19:26:17.844  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:26:17.844开始执行getAllType
2020-04-29 19:26:17.880  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:26:17.880执行完成getAllType
2020-04-29 19:26:17.880  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:26:17.906  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:26:17.906执行完成blogPage
2020-04-29 19:26:17.907  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:26:19.751  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:26:19.751开始执行typePage
2020-04-29 19:26:19.816  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:26:19.816执行完成typePage
2020-04-29 19:26:19.816  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:26:31.151  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:26:31.151开始执行typePage
2020-04-29 19:26:31.216  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:26:31.216执行完成typePage
2020-04-29 19:26:31.216  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:26:32.498  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:26:32.498开始执行typePage
2020-04-29 19:26:32.561  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:26:32.561执行完成typePage
2020-04-29 19:26:32.561  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:26:39.839  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:26:39.839开始执行blogPage
2020-04-29 19:26:39.842  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:26:39.842开始执行getAllType
2020-04-29 19:26:39.876  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:26:39.876执行完成getAllType
2020-04-29 19:26:39.877  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:26:39.908  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:26:39.908执行完成blogPage
2020-04-29 19:26:39.910  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:26:59.367  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:26:59.367开始执行blogPage
2020-04-29 19:26:59.369  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:26:59.369开始执行getAllType
2020-04-29 19:26:59.404  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:26:59.404执行完成getAllType
2020-04-29 19:26:59.404  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:26:59.430  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:26:59.430执行完成blogPage
2020-04-29 19:26:59.431  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:27:03.597  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:27:03.597开始执行blogPage
2020-04-29 19:27:03.599  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:03.599开始执行getAllType
2020-04-29 19:27:03.633  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:03.633执行完成getAllType
2020-04-29 19:27:03.633  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:27:03.660  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:27:03.660执行完成blogPage
2020-04-29 19:27:03.665  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:27:09.496  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:27:09.496开始执行blogPage
2020-04-29 19:27:09.498  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:09.498开始执行getAllType
2020-04-29 19:27:09.532  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:09.532执行完成getAllType
2020-04-29 19:27:09.532  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:27:09.560  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:27:09.560执行完成blogPage
2020-04-29 19:27:09.565  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:27:12.525  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:27:12.525开始执行blogPage
2020-04-29 19:27:12.527  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:12.527开始执行getAllType
2020-04-29 19:27:12.560  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:12.560执行完成getAllType
2020-04-29 19:27:12.560  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:27:12.590  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:27:12.590执行完成blogPage
2020-04-29 19:27:12.593  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:27:27.911  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:27:27.911开始执行blogPage
2020-04-29 19:27:27.913  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:27.913开始执行getAllType
2020-04-29 19:27:27.947  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:27:27.947执行完成getAllType
2020-04-29 19:27:27.947  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:27:27.974  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:27:27.974执行完成blogPage
2020-04-29 19:27:27.979  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:27:45.252  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:27:45.252开始执行getAllType
2020-04-29 19:27:45.285  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:27:45.285执行完成getAllType
2020-04-29 19:27:45.285  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:27:48.026  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:27:48.026开始执行typePage
2020-04-29 19:27:48.095  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:27:48.095执行完成typePage
2020-04-29 19:27:48.095  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:27:55.129  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:27:55.129开始执行getAllType
2020-04-29 19:27:55.162  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:27:55.162执行完成getAllType
2020-04-29 19:27:55.162  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:27:55.795 ERROR 20696 --- [http-nio-80-exec-2] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-2] Exception processing template "admin/user": Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers

org.thymeleaf.exceptions.TemplateInputException: Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers
	at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:869) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 19:27:55.801 ERROR 20696 --- [http-nio-80-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers] with root cause

org.thymeleaf.exceptions.TemplateInputException: Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers
	at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:869) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 19:28:43.281 ERROR 20696 --- [http-nio-80-exec-7] org.thymeleaf.TemplateEngine             : [THYMELEAF][http-nio-80-exec-7] Exception processing template "admin/user": Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers

org.thymeleaf.exceptions.TemplateInputException: Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers
	at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:869) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) [thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) [thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 19:28:43.285 ERROR 20696 --- [http-nio-80-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.thymeleaf.exceptions.TemplateInputException: Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers] with root cause

org.thymeleaf.exceptions.TemplateInputException: Error resolving template [admin/user], template might not exist or might not be accessible by any of the configured Template Resolvers
	at org.thymeleaf.engine.TemplateManager.resolveTemplate(TemplateManager.java:869) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.engine.TemplateManager.parseAndProcess(TemplateManager.java:607) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1098) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.TemplateEngine.process(TemplateEngine.java:1072) ~[thymeleaf-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.renderFragment(ThymeleafView.java:362) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.thymeleaf.spring5.view.ThymeleafView.render(ThymeleafView.java:189) ~[thymeleaf-spring5-3.0.11.RELEASE.jar:3.0.11.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.render(DispatcherServlet.java:1373) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.processDispatchResult(DispatcherServlet.java:1118) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1057) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) ~[druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]

2020-04-29 19:28:52.305  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:28:52.305开始执行getAllType
2020-04-29 19:28:52.340  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:28:52.340执行完成getAllType
2020-04-29 19:28:52.340  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:28:55.190  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:28:55.190开始执行count
2020-04-29 19:28:55.222  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:28:55.222执行完成count
2020-04-29 19:28:55.223  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:28:55.228  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:28:55.228开始执行index
2020-04-29 19:28:55.297  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:28:55.297执行完成index
2020-04-29 19:28:55.297  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:03.436  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:29:03.436开始执行blogPage
2020-04-29 19:29:03.438  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:29:03.438开始执行getAllType
2020-04-29 19:29:03.501  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:29:03.501执行完成blogPage
2020-04-29 19:29:03.506  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:03.508  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:29:03.508执行完成getAllType
2020-04-29 19:29:03.508  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:29:05.519  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:29:05.519开始执行typePage
2020-04-29 19:29:05.593  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:29:05.593执行完成typePage
2020-04-29 19:29:05.593  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:29:06.580  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:29:06.580开始执行getAllType
2020-04-29 19:29:06.615  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:29:06.615执行完成getAllType
2020-04-29 19:29:06.615  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:29:11.375  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:29:11.375开始执行count
2020-04-29 19:29:11.409  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:29:11.409执行完成count
2020-04-29 19:29:11.409  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:29:11.413  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:29:11.413开始执行index
2020-04-29 19:29:11.480  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:29:11.480执行完成index
2020-04-29 19:29:11.480  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:19.423  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:29:19.423开始执行count
2020-04-29 19:29:19.423  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:29:19.423开始执行index
2020-04-29 19:29:19.459  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:29:19.459执行完成count
2020-04-29 19:29:19.459  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:4
2020-04-29 19:29:19.494  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:29:19.494执行完成index
2020-04-29 19:29:19.494  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:19.501  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:29:19.501开始执行index
2020-04-29 19:29:19.571  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:29:19.571执行完成index
2020-04-29 19:29:19.572  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=4, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:31.993  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:29:31.993开始执行count
2020-04-29 19:29:32.027  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:29:32.027执行完成count
2020-04-29 19:29:32.027  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:29:32.031  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:29:32.031开始执行index
2020-04-29 19:29:32.097  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:29:32.097执行完成index
2020-04-29 19:29:32.098  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:34.242  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:29:34.242开始执行index
2020-04-29 19:29:34.308  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:29:34.308执行完成index
2020-04-29 19:29:34.308  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:35.711  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:29:35.711开始执行index
2020-04-29 19:29:35.777  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:29:35.777执行完成index
2020-04-29 19:29:35.777  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:38.140  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:29:38.140开始执行blogPage
2020-04-29 19:29:38.142  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:29:38.142开始执行getAllType
2020-04-29 19:29:38.173  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:29:38.173执行完成getAllType
2020-04-29 19:29:38.173  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:29:38.206  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:29:38.206执行完成blogPage
2020-04-29 19:29:38.210  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:29:41.425  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:29:41.425开始执行typePage
2020-04-29 19:29:41.491  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:29:41.491执行完成typePage
2020-04-29 19:29:41.491  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:29:59.653  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:29:59.653开始执行typePage
2020-04-29 19:29:59.718  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:29:59.718执行完成typePage
2020-04-29 19:29:59.719  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:30:01.265  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:30:01.265开始执行typePage
2020-04-29 19:30:01.330  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:30:01.330执行完成typePage
2020-04-29 19:30:01.330  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:30:02.653  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:30:02.653开始执行getAllType
2020-04-29 19:30:02.686  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:30:02.686执行完成getAllType
2020-04-29 19:30:02.686  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:30:20.863  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:30:20.863开始执行count
2020-04-29 19:30:20.898  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:30:20.898执行完成count
2020-04-29 19:30:20.898  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:30:20.905  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:30:20.905开始执行index
2020-04-29 19:30:20.971  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:30:20.971执行完成index
2020-04-29 19:30:20.971  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:30:33.246  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:30:33.246开始执行index
2020-04-29 19:30:33.312  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:30:33.312执行完成index
2020-04-29 19:30:33.312  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:30:42.000  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:30:42开始执行count
2020-04-29 19:30:42.033  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:30:42.033执行完成count
2020-04-29 19:30:42.033  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:30:42.039  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:30:42.039开始执行index
2020-04-29 19:30:42.104  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:30:42.104执行完成index
2020-04-29 19:30:42.104  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:30:42.947  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:30:42.947开始执行getContent
2020-04-29 19:30:43.008  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:30:43.008执行完成getContent
2020-04-29 19:30:43.008  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=<h3 id="1什么是http协议">1.什么是http协议?</h3>
<ul>
<li>http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科</li>
<li>http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙</li>
</ul>
<ol>
<li>request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.</li>
<li>page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧</li>
<li>session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新</li>
<li>context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取</li>
</ol>
<h3 id="2转发和重定向">2.转发和重定向</h3>
<ul>
<li>java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应</li>
<li>java通过response.sendRedirect(&quot;路径&quot;)进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............</li>
</ul>
)}]
2020-04-29 19:30:50.508  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:30:50.508开始执行getContent
2020-04-29 19:30:50.548  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:30:50.548执行完成getContent
2020-04-29 19:30:50.548  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ModelAndView [view="content"; model={blog=Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=<h3 id="1docker是什么">1.docker是什么?</h3>
<ul>
<li>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科</li>
</ul>
<h3 id="2容器和镜像的概念">2.容器和镜像的概念</h3>
<ul>
<li>镜像简单来说相当于安装包,而且这个安装包可以安装多次.</li>
<li>容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.</li>
<li>docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)</li>
<li>docker搜索jdk镜像:  docker search  jdk</li>
<li>docker查看下载的镜像: docker images</li>
<li>docker下载jdk镜像:  docker  pull  ascdc/jdk8</li>
<li>docker查看运行中的容器: docker ps</li>
<li>docker查看所有容器: docker ps -a
<img src="http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png" alt="" /></li>
</ul>
<p><img src="http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png" alt="" /></p>
<h3 id="3容器id和镜像id的作用">3.容器id和镜像id的作用</h3>
<ul>
<li>id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件</li>
<li>删除镜像: docker rmi 镜像的id或者镜像的名字</li>
<li>删除容器必须之前先停止容器: docker stop 容器id或者容器name</li>
<li>docker rm 容器id或者容器name</li>
</ul>
<h3 id="4其他操作">4.其他操作</h3>
<ul>
<li>重启docker: systemctl restart docker</li>
<li>最好用的命令: docker --help</li>
<li>进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash</li>
</ul>
)}]
2020-04-29 19:31:22.982  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:31:22.982开始执行blogPage
2020-04-29 19:31:22.984  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:31:22.984开始执行getAllType
2020-04-29 19:31:23.049  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:31:23.049执行完成blogPage
2020-04-29 19:31:23.050  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:31:23.052  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:31:23.052执行完成getAllType
2020-04-29 19:31:23.052  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:31:24.697  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:31:24.697开始执行typePage
2020-04-29 19:31:24.764  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:31:24.764执行完成typePage
2020-04-29 19:31:24.764  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:31:25.484  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:31:25.484开始执行getAllType
2020-04-29 19:31:25.516  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:31:25.516执行完成getAllType
2020-04-29 19:31:25.516  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:31:31.179  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:31:31.179开始执行typePage
2020-04-29 19:31:31.246  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:31:31.246执行完成typePage
2020-04-29 19:31:31.246  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:31:38.774  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:31:38.774开始执行blogPage
2020-04-29 19:31:38.776  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:31:38.776开始执行getAllType
2020-04-29 19:31:38.813  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:31:38.813执行完成getAllType
2020-04-29 19:31:38.814  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:31:38.846  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:31:38.846执行完成blogPage
2020-04-29 19:31:38.847  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:37:07.122  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:37:07.122开始执行blogPage
2020-04-29 19:37:07.125  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:37:07.125开始执行getAllType
2020-04-29 19:37:09.129  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:37:09.129执行完成blogPage
2020-04-29 19:37:09.129  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:37:09.129执行完成getAllType
2020-04-29 19:37:09.135 ERROR 20696 --- [http-nio-80-exec-4] c.b.handler.ControllerExceptionHandler   : Request URL : http://localhost/blog/blog-type/admin/getAllType,EXxception : {}

org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
### The error may exist in com/blog/mapper/BlogTypeMapper.java (best guess)
### The error may involve com.blog.mapper.BlogTypeMapper.selectList
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:77) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at com.sun.proxy.$Proxy104.selectList(Unknown Source) ~[na:na]
	at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at com.baomidou.mybatisplus.core.override.PageMapperMethod.executeForMany(PageMapperMethod.java:173) ~[mybatis-plus-core-3.0.5.jar:na]
	at com.baomidou.mybatisplus.core.override.PageMapperMethod.execute(PageMapperMethod.java:86) ~[mybatis-plus-core-3.0.5.jar:na]
	at com.baomidou.mybatisplus.core.override.PageMapperProxy.invoke(PageMapperProxy.java:64) ~[mybatis-plus-core-3.0.5.jar:na]
	at com.sun.proxy.$Proxy257.selectList(Unknown Source) ~[na:na]
	at com.baomidou.mybatisplus.extension.service.impl.ServiceImpl.list(ServiceImpl.java:315) ~[mybatis-plus-extension-3.0.5.jar:na]
	at com.baomidou.mybatisplus.extension.service.impl.ServiceImpl$$FastClassBySpringCGLIB$$76535273.invoke(<generated>) ~[mybatis-plus-extension-3.0.5.jar:na]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at com.blog.service.impl.BlogTypeServiceImpl$$EnhancerBySpringCGLIB$$bef079c7.list(<generated>) ~[classes/:na]
	at com.blog.controller.BlogTypeController.getAllType(BlogTypeController.java:69) ~[classes/:na]
	at com.blog.controller.BlogTypeController$$FastClassBySpringCGLIB$$90056cab.invoke(<generated>) ~[classes/:na]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.aspectj.AspectJAfterAdvice.invoke(AspectJAfterAdvice.java:47) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at com.blog.controller.BlogTypeController$$EnhancerBySpringCGLIB$$2f73846a.getAllType(<generated>) ~[classes/:na]
	at sun.reflect.GeneratedMethodAccessor413.invoke(Unknown Source) ~[na:na]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_131]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_131]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
### The error may exist in com/blog/mapper/BlogTypeMapper.java (best guess)
### The error may involve com.blog.mapper.BlogTypeMapper.selectList
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:150) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) ~[mybatis-3.4.6.jar:3.4.6]
	at sun.reflect.GeneratedMethodAccessor125.invoke(Unknown Source) ~[na:na]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_131]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_131]
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) ~[mybatis-spring-1.3.2.jar:1.3.2]
	... 83 common frames omitted
Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:82) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:82) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at org.mybatis.spring.transaction.SpringManagedTransaction.getConnection(SpringManagedTransaction.java:68) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:338) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:84) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) ~[mybatis-3.4.6.jar:3.4.6]
	at sun.reflect.GeneratedMethodAccessor111.invoke(Unknown Source) ~[na:na]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_131]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_131]
	at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:63) ~[mybatis-3.4.6.jar:3.4.6]
	at com.sun.proxy.$Proxy147.query(Unknown Source) ~[na:na]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) ~[mybatis-3.4.6.jar:3.4.6]
	... 88 common frames omitted
Caused by: com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1358) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:1255) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5007) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:680) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5003) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1233) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1225) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:90) ~[druid-1.1.10.jar:1.1.10]
	at org.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:158) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:116) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:79) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	... 103 common frames omitted

2020-04-29 19:37:09.135 ERROR 20696 --- [http-nio-80-exec-10] c.b.handler.ControllerExceptionHandler   : Request URL : http://localhost/blog/blog/admin/blogPage,EXxception : {}

org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
### The error may exist in com/blog/mapper/BlogMapper.java (best guess)
### The error may involve com.blog.mapper.BlogMapper.selectPage
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:77) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:446) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at com.sun.proxy.$Proxy104.selectList(Unknown Source) ~[na:na]
	at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at com.baomidou.mybatisplus.core.override.PageMapperMethod.executeForMany2(PageMapperMethod.java:128) ~[mybatis-plus-core-3.0.5.jar:na]
	at com.baomidou.mybatisplus.core.override.PageMapperMethod.execute(PageMapperMethod.java:98) ~[mybatis-plus-core-3.0.5.jar:na]
	at com.baomidou.mybatisplus.core.override.PageMapperProxy.invoke(PageMapperProxy.java:64) ~[mybatis-plus-core-3.0.5.jar:na]
	at com.sun.proxy.$Proxy255.selectPage(Unknown Source) ~[na:na]
	at com.blog.service.impl.BlogServiceImpl.page(BlogServiceImpl.java:43) ~[classes/:na]
	at com.blog.service.impl.BlogServiceImpl$$FastClassBySpringCGLIB$$257eb4bd.invoke(<generated>) ~[classes/:na]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:687) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at com.blog.service.impl.BlogServiceImpl$$EnhancerBySpringCGLIB$$17e224d5.page(<generated>) ~[classes/:na]
	at com.blog.controller.BlogController.blogPage(BlogController.java:41) ~[classes/:na]
	at com.blog.controller.BlogController$$FastClassBySpringCGLIB$$87fca451.invoke(<generated>) ~[classes/:na]
	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218) ~[spring-core-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:771) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:56) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.aspectj.AspectJAfterAdvice.invoke(AspectJAfterAdvice.java:47) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor.invoke(AfterReturningAdviceInterceptor.java:55) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:749) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:691) ~[spring-aop-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at com.blog.controller.BlogController$$EnhancerBySpringCGLIB$$6aee231c.blogPage(<generated>) ~[classes/:na]
	at sun.reflect.GeneratedMethodAccessor412.invoke(Unknown Source) ~[na:na]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_131]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_131]
	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:105) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943) ~[spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:898) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883) [spring-webmvc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) [tomcat-embed-websocket-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) [druid-1.1.10.jar:1.1.10]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119) [spring-web-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:541) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:373) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:868) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1594) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_131]
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_131]
	at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.33.jar:9.0.33]
	at java.lang.Thread.run(Thread.java:748) [na:1.8.0_131]
Caused by: org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
### The error may exist in com/blog/mapper/BlogMapper.java (best guess)
### The error may involve com.blog.mapper.BlogMapper.selectPage
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:30) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:150) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141) ~[mybatis-3.4.6.jar:3.4.6]
	at sun.reflect.GeneratedMethodAccessor125.invoke(Unknown Source) ~[na:na]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_131]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_131]
	at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433) ~[mybatis-spring-1.3.2.jar:1.3.2]
	... 83 common frames omitted
Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:82) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.mybatis.spring.transaction.SpringManagedTransaction.openConnection(SpringManagedTransaction.java:82) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at org.mybatis.spring.transaction.SpringManagedTransaction.getConnection(SpringManagedTransaction.java:68) ~[mybatis-spring-1.3.2.jar:1.3.2]
	at org.apache.ibatis.executor.BaseExecutor.getConnection(BaseExecutor.java:338) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:84) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109) ~[mybatis-3.4.6.jar:3.4.6]
	at org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:83) ~[mybatis-3.4.6.jar:3.4.6]
	at sun.reflect.GeneratedMethodAccessor111.invoke(Unknown Source) ~[na:na]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_131]
	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_131]
	at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:63) ~[mybatis-3.4.6.jar:3.4.6]
	at com.sun.proxy.$Proxy147.query(Unknown Source) ~[na:na]
	at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148) ~[mybatis-3.4.6.jar:3.4.6]
	... 88 common frames omitted
Caused by: com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
	at com.alibaba.druid.pool.DruidDataSource.getConnectionInternal(DruidDataSource.java:1358) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:1255) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5007) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.filter.stat.StatFilter.dataSource_getConnection(StatFilter.java:680) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:5003) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1233) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:1225) ~[druid-1.1.10.jar:1.1.10]
	at com.alibaba.druid.pool.DruidDataSource.getConnection(DruidDataSource.java:90) ~[druid-1.1.10.jar:1.1.10]
	at org.springframework.jdbc.datasource.DataSourceUtils.fetchConnection(DataSourceUtils.java:158) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.jdbc.datasource.DataSourceUtils.doGetConnection(DataSourceUtils.java:116) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:79) ~[spring-jdbc-5.2.5.RELEASE.jar:5.2.5.RELEASE]
	... 103 common frames omitted

2020-04-29 19:37:09.136  WARN 20696 --- [http-nio-80-exec-10] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
### The error may exist in com/blog/mapper/BlogMapper.java (best guess)
### The error may involve com.blog.mapper.BlogMapper.selectPage
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020]
2020-04-29 19:37:09.136  WARN 20696 --- [http-nio-80-exec-4] .m.m.a.ExceptionHandlerExceptionResolver : Resolved [org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException: 
### Error querying database.  Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020
### The error may exist in com/blog/mapper/BlogTypeMapper.java (best guess)
### The error may involve com.blog.mapper.BlogTypeMapper.selectList
### The error occurred while executing a query
### Cause: org.springframework.jdbc.CannotGetJdbcConnectionException: Failed to obtain JDBC Connection; nested exception is com.alibaba.druid.pool.DataSourceClosedException: dataSource already closed at Wed Apr 29 19:37:08 CST 2020]
2020-04-29 19:37:09.424  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Starting BlogApplication on hz with PID 20696 (E:\java\blog\target\classes started by 1 in E:\java\blog)
2020-04-29 19:37:09.424  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : The following profiles are active: dev
2020-04-29 19:37:12.072  WARN 20696 --- [restartedMain] org.thymeleaf.templatemode.TemplateMode  : [THYMELEAF][restartedMain] Template Mode 'HTML5' is deprecated. Using Template Mode 'HTML' instead.
2020-04-29 19:37:12.246  INFO 20696 --- [restartedMain] com.blog.BlogApplication                 : Started BlogApplication in 2.842 seconds (JVM running for 3495.796)
2020-04-29 19:37:12.796  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:37:12.796开始执行typePage
2020-04-29 19:37:12.878  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:37:12.878执行完成typePage
2020-04-29 19:37:12.879  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:37:16.262  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:37:16.262开始执行count
2020-04-29 19:37:16.299  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:37:16.299执行完成count
2020-04-29 19:37:16.299  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:8
2020-04-29 19:37:16.304  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:37:16.304开始执行index
2020-04-29 19:37:16.372  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:37:16.372执行完成index
2020-04-29 19:37:16.372  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:37:25.589  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:37:25.589开始执行blogPage
2020-04-29 19:37:25.590  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:37:25.590开始执行getAllType
2020-04-29 19:37:25.632  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:37:25.632执行完成getAllType
2020-04-29 19:37:25.632  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:37:25.654  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:37:25.654执行完成blogPage
2020-04-29 19:37:25.654  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:37:28.539  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:37:28.539开始执行typePage
2020-04-29 19:37:28.604  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:37:28.604执行完成typePage
2020-04-29 19:37:28.604  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:37:29.196  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:37:29.196开始执行getAllType
2020-04-29 19:37:29.230  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:37:29.230执行完成getAllType
2020-04-29 19:37:29.230  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:37:31.095  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:37:31.095开始执行typePage
2020-04-29 19:37:31.158  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:37:31.158执行完成typePage
2020-04-29 19:37:31.159  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:37:31.804  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:37:31.804开始执行blogPage
2020-04-29 19:37:31.805  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:37:31.805开始执行getAllType
2020-04-29 19:37:31.840  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:37:31.840执行完成getAllType
2020-04-29 19:37:31.840  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:37:31.870  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:37:31.870执行完成blogPage
2020-04-29 19:37:31.872  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:37:43.140  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:37:43.140开始执行blogPage
2020-04-29 19:37:43.142  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:37:43.142开始执行getAllType
2020-04-29 19:37:43.178  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:37:43.178执行完成getAllType
2020-04-29 19:37:43.178  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:37:43.206  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:37:43.206执行完成blogPage
2020-04-29 19:37:43.210  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:37:52.029  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:37:52.029开始执行blogPage
2020-04-29 19:37:52.030  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:37:52.030开始执行getAllType
2020-04-29 19:37:52.070  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:37:52.070执行完成getAllType
2020-04-29 19:37:52.070  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:37:52.105  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:37:52.105执行完成blogPage
2020-04-29 19:37:52.106  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:39:23.071  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.071开始执行blogPage
2020-04-29 19:39:23.073  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.073开始执行getAllType
2020-04-29 19:39:23.154  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.154执行完成getAllType
2020-04-29 19:39:23.154  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:39:23.181  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.181执行完成blogPage
2020-04-29 19:39:23.183  INFO 20696 --- [http-nio-80-exec-10] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:39:23.850  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.850开始执行blogPage
2020-04-29 19:39:23.852  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.852开始执行getAllType
2020-04-29 19:39:23.887  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.887执行完成getAllType
2020-04-29 19:39:23.887  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:39:23.916  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:39:23.916执行完成blogPage
2020-04-29 19:39:23.921  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:39:46.725  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:39:46.725开始执行blogPage
2020-04-29 19:39:46.728  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:39:46.728开始执行getAllType
2020-04-29 19:39:46.763  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:39:46.763执行完成getAllType
2020-04-29 19:39:46.763  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:39:46.791  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:39:46.791执行完成blogPage
2020-04-29 19:39:46.795  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:39:47.964  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:39:47.964开始执行blogPage
2020-04-29 19:39:47.966  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:39:47.966开始执行getAllType
2020-04-29 19:39:48.001  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:39:48.001执行完成getAllType
2020-04-29 19:39:48.001  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:39:48.031  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:39:48.031执行完成blogPage
2020-04-29 19:39:48.035  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=8, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=5, original=0, commentable=0, createTime=Tue Apr 28 06:47:25 CST 2020, updateTime=Tue Apr 28 06:47:25 CST 2020, flag=1, appreciate=0, typeId=0, title=sb, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:39:53.318  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:39:53.318开始执行deleteBlog
2020-04-29 19:39:53.487  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:39:53.487执行完成deleteBlog
2020-04-29 19:39:53.487  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:删除成功
2020-04-29 19:40:03.590  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:40:03.590开始执行blogPage
2020-04-29 19:40:03.592  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:40:03.592开始执行getAllType
2020-04-29 19:40:03.629  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:40:03.629执行完成getAllType
2020-04-29 19:40:03.629  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:40:03.656  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:40:03.656执行完成blogPage
2020-04-29 19:40:03.656  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:40:09.010  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:40:09.010开始执行typePage
2020-04-29 19:40:09.080  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:40:09.080执行完成typePage
2020-04-29 19:40:09.080  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=15, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch)])
2020-04-29 19:40:09.642  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:40:09.642开始执行getAllType
2020-04-29 19:40:09.675  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:40:09.675执行完成getAllType
2020-04-29 19:40:09.675  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:40:20.967  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:40:20.967开始执行blogPage
2020-04-29 19:40:20.968  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:40:20.968开始执行getAllType
2020-04-29 19:40:21.003  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : 2020-04-29T19:40:21.003执行完成getAllType
2020-04-29 19:40:21.003  INFO 20696 --- [http-nio-80-exec-5] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=null, data=[BlogType(id=1, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:02 CST 2020, flag=1, num=0, typeName=java基础上), BlogType(id=2, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Mon Apr 27 21:36:06 CST 2020, flag=1, num=0, typeName=java基础下), BlogType(id=3, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java web), BlogType(id=4, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=java高级), BlogType(id=5, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=html), BlogType(id=6, createTime=Tue Apr 28 04:39:27 CST 2020, updateTime=Tue Apr 28 04:39:27 CST 2020, flag=1, num=0, typeName=css), BlogType(id=7, createTime=Tue Apr 28 05:04:01 CST 2020, updateTime=Tue Apr 28 05:04:01 CST 2020, flag=1, num=0, typeName=ssm), BlogType(id=8, createTime=Tue Apr 28 05:04:13 CST 2020, updateTime=Tue Apr 28 05:04:13 CST 2020, flag=1, num=0, typeName=spring boot), BlogType(id=9, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=spring cloud), BlogType(id=10, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=elasticsearch), BlogType(id=11, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=solr), BlogType(id=12, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=sso), BlogType(id=13, createTime=Tue Apr 28 05:05:24 CST 2020, updateTime=Tue Apr 28 05:05:24 CST 2020, flag=1, num=0, typeName=log), BlogType(id=15, createTime=Tue Apr 28 18:21:38 CST 2020, updateTime=Tue Apr 28 18:21:38 CST 2020, flag=1, num=0, typeName=网站的搭建), BlogType(id=16, createTime=Tue Apr 28 18:33:45 CST 2020, updateTime=Tue Apr 28 18:33:45 CST 2020, flag=1, num=0, typeName=docker)])
2020-04-29 19:40:21.032  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:40:21.032执行完成blogPage
2020-04-29 19:40:21.032  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:40:51.563  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:40:51.563开始执行count
2020-04-29 19:40:51.597  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:40:51.597执行完成count
2020-04-29 19:40:51.597  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:7
2020-04-29 19:40:51.603  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:40:51.603开始执行index
2020-04-29 19:40:51.669  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:40:51.669执行完成index
2020-04-29 19:40:51.669  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:40:54.867  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:40:54.867开始执行index
2020-04-29 19:40:54.932  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : 2020-04-29T19:40:54.932执行完成index
2020-04-29 19:40:54.932  INFO 20696 --- [http-nio-80-exec-4] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:40:58.423  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:40:58.423开始执行index
2020-04-29 19:40:58.490  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:40:58.490执行完成index
2020-04-29 19:40:58.491  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:41:06.662  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:41:06.662开始执行count
2020-04-29 19:41:06.695  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : 2020-04-29T19:41:06.695执行完成count
2020-04-29 19:41:06.696  INFO 20696 --- [http-nio-80-exec-3] com.blog.aspect.LogAspect                : Result:7
2020-04-29 19:41:06.699  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:41:06.699开始执行index
2020-04-29 19:41:06.768  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:41:06.768执行完成index
2020-04-29 19:41:06.768  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:48:49.903  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:48:49.903开始执行count
2020-04-29 19:48:51.942  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:48:51.942执行完成count
2020-04-29 19:48:51.942  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:7
2020-04-29 19:48:51.947  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:48:51.947开始执行index
2020-04-29 19:48:52.021  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:48:52.021执行完成index
2020-04-29 19:48:52.022  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:48:59.498  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:48:59.498开始执行index
2020-04-29 19:48:59.559  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : 2020-04-29T19:48:59.559执行完成index
2020-04-29 19:48:59.559  INFO 20696 --- [http-nio-80-exec-8] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=3, original=1, commentable=1, createTime=Tue Apr 28 05:56:56 CST 2020, updateTime=Tue Apr 28 05:56:56 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=2, original=1, commentable=1, createTime=Tue Apr 28 05:56:55 CST 2020, updateTime=Tue Apr 28 05:56:55 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=1, original=1, commentable=1, createTime=Tue Apr 28 05:56:52 CST 2020, updateTime=Tue Apr 28 05:56:52 CST 2020, flag=1, appreciate=1, typeId=1, title=Java开发, outline=卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:49:00.604  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:49:00.604开始执行index
2020-04-29 19:49:00.665  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : 2020-04-29T19:49:00.665执行完成index
2020-04-29 19:49:00.665  INFO 20696 --- [http-nio-80-exec-1] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:49:03.626  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:49:03.626开始执行count
2020-04-29 19:49:03.657  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : 2020-04-29T19:49:03.657执行完成count
2020-04-29 19:49:03.657  INFO 20696 --- [http-nio-80-exec-2] com.blog.aspect.LogAspect                : Result:7
2020-04-29 19:49:03.661  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:49:03.661开始执行index
2020-04-29 19:49:03.721  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : 2020-04-29T19:49:03.721执行完成index
2020-04-29 19:49:03.721  INFO 20696 --- [http-nio-80-exec-9] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
2020-04-29 19:49:12.051  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:49:12.051开始执行count
2020-04-29 19:49:12.082  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : 2020-04-29T19:49:12.082执行完成count
2020-04-29 19:49:12.082  INFO 20696 --- [http-nio-80-exec-6] com.blog.aspect.LogAspect                : Result:7
2020-04-29 19:49:12.087  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:49:12.087开始执行index
2020-04-29 19:49:12.147  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : 2020-04-29T19:49:12.147执行完成index
2020-04-29 19:49:12.147  INFO 20696 --- [http-nio-80-exec-7] com.blog.aspect.LogAspect                : Result:ResultBean(msg=success, code=0, count=7, data=[Blog(id=10, original=1, commentable=1, createTime=Wed Apr 29 14:31:48 CST 2020, updateTime=Wed Apr 29 14:31:48 CST 2020, flag=1, appreciate=1, typeId=3, title=java web中的域对象, outline=http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b3768f7cd0b04e4b9315f58f3ee2a3f0, content=### 1.什么是http协议?
- http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。─────来自百度百科
- http协议是无状态的,每次只能产生一次请求和响应.所以不能很好的保存数据需要域对象来帮忙
1. request对象它是一个域对象,所有的域对象都有三种方法set get remove即设置,获得和移除值,域对象都有作用域,request的作用域是一次请求和响应.
2. page域对象它的作用域是在当前网页有效,它的作用域比request小,一般用不上吧
3. session域对象的作用域是一次会话有效,一次会话简单理解就是浏览器关闭和打开,关闭浏览器session就失效了.保持浏览器的打开会话就存在,session的默认有效时间是30分钟如果我们放任浏览器不管,30分钟后session也会失效,但是如果我们时不时点一下,session的有效时间就会得到刷新
4. context这个域对象的作用域是服务级别的,只要web应用没有关闭或重启域对象中的值就可以通过get方法去获取
### 2.转发和重定向
- java通过request对象进行转发,request域对象中的值依然有效,即转发是一次请求和响应
- java通过response.sendRedirect("路径")进行重定向,request中的值也会失效,同时url的地址也会改变
未完待续............), Blog(id=9, original=1, commentable=1, createTime=Tue Apr 28 19:18:11 CST 2020, updateTime=Tue Apr 28 19:18:11 CST 2020, flag=1, appreciate=1, typeId=16, title=docker的基本使用, outline=Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科, avatar=http://q9hljz6bo.bkt.clouddn.com/b462227dcee54b63aa52c29f3f5efd73, content=### 1.docker是什么?
- Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。─────来自百度百科
### 2.容器和镜像的概念
- 镜像简单来说相当于安装包,而且这个安装包可以安装多次.
- 容器就是安装包安装好了,镜像安装时可以指定端口号和名字等等.
- docker 安装镜像生成容器:docker run -d -p 80:80 --name testname 镜像id (参数说明,run表示安装的动作,-d作用是让容器后台可以运行,-p是指定端口号80:80,第一个80是访问容器的端口号,第二个相当于一个标识,--name是给容器起一个名字,镜像id是选择对应的镜像进行安装)
- docker搜索jdk镜像:  docker search  jdk
- docker查看下载的镜像: docker images
- docker下载jdk镜像:  docker  pull  ascdc/jdk8
- docker查看运行中的容器: docker ps
- docker查看所有容器: docker ps -a
![](http://q9hljz6bo.bkt.clouddn.com/5%25G%5B%254IH9%28JH%40GX6ROX7%283D.png)

![](http://q9hljz6bo.bkt.clouddn.com/CQ6%2437%7BRURIMQRR7%298DIT8T.png)

### 3.容器id和镜像id的作用
- id起到一个唯一标识的作用,当我们要删除某个镜像,或者停止和删除容器时可以id来选择需要删除的容器或者镜像.name属性也可以作为选择的条件
- 删除镜像: docker rmi 镜像的id或者镜像的名字
- 删除容器必须之前先停止容器: docker stop 容器id或者容器name
- docker rm 容器id或者容器name
### 4.其他操作
- 重启docker: systemctl restart docker
- 最好用的命令: docker --help
- 进入容器内部(拿mysql来说): docker exec -it mysql容器的id或name bash), Blog(id=6, original=1, commentable=1, createTime=Tue Apr 28 06:47:50 CST 2020, updateTime=Tue Apr 28 06:47:50 CST 2020, flag=1, appreciate=1, typeId=1, title=sc, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下), Blog(id=4, original=1, commentable=1, createTime=Tue Apr 28 06:45:09 CST 2020, updateTime=Tue Apr 28 06:45:09 CST 2020, flag=1, appreciate=0, typeId=0, title=ssm, outline=卡片式面板面板通常用于非 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影卡片式面板面板通常用于非白色背景色的主体内 从而映衬出边框投影, avatar=/static/img/back.jpg, content=内容如下)])
